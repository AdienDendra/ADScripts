import pymel.core as pm
import maya.cmds as mc
import maya.OpenMaya as om
from functools import partial
import re
from string import digits
import os
import pickle
import maya.mel as mm

WORLD = [[2.249819018465117e-06, 4.4954081543323836e-21, -0.9995246068942343],
         [-0.14364550934591647, 4.4954081543323836e-21, -0.8558768477293006],
         [-0.071821629763449, 4.4954081543323836e-21, -0.8558768477293006],
         [-0.07182162976344904, 4.4954081543323836e-21, -0.7122290885643646],
         [-0.088386409295832, 2.0846451730833405e-17, -0.7108157938106947],
         [-0.1061349197992234, 3.424365103258661e-17, -0.7088070525039724],
         [-0.12501357709855218, 4.497229342741604e-17, -0.7063385569153456],
         [-0.14346314528846507, 4.5393406538715825e-17, -0.7035113744664869],
         [-0.16174000089634305, 4.438578325514239e-17, -0.6998018603824748],
         [-0.17978550363873633, 4.204809138186353e-17, -0.6949578325308288],
         [-0.1977083608059601, 4.1243774524624774e-17, -0.6897328753554542],
         [-0.21555724337727425, 4.14225688486721e-17, -0.6842437171243055],
         [-0.23332973449821515, 4.2521704366388776e-17, -0.6785201391792451],
         [-0.25090703521792, 4.110606733572579e-17, -0.6722116297263254],
         [-0.26830200524946435, 4.048648655099494e-17, -0.6654334932404337],
         [-0.2855187684402299, 4.031687187935323e-17, -0.6582016936643575],
         [-0.30254880350042124, 3.987962028811478e-17, -0.6505416471727158],
         [-0.3193930681286763, 3.9383551536911306e-17, -0.6424878958416353],
         [-0.3360558301637971, 3.8798026965829384e-17, -0.634059768877937],
         [-0.3524512734001972, 3.828035662596862e-17, -0.6251207556479854],
         [-0.3686199003548641, 3.771530917600967e-17, -0.6157856020439431],
         [-0.38456488141059475, 3.711548796341085e-17, -0.6060669447951867],
         [-0.400232558958288, 3.649364150355613e-17, -0.5959065280382044],
         [-0.4156433972813192, 3.5847798846401436e-17, -0.585367121368167],
         [-0.4308011482177873, 3.5179663496699165e-17, -0.5744615036379386],
         [-0.44561771917015786, 3.448426697901553e-17, -0.563095619040009],
         [-0.46013820332983396, 3.376583309756324e-17, -0.5513603654680082],
         [-0.4743666884032504, 3.3025127486903226e-17, -0.5392670202284431],
         [-0.4882347416719026, 3.225933955264423e-17, -0.5267616317911085],
         [-0.5017849672351886, 3.1472900139070075e-17, -0.5139179908469292],
         [-0.515020932440063, 3.06664316539793e-17, -0.5007459415445104],
         [-0.5278091698623874, 2.9833164232413545e-17, -0.48713832513880045],
         [-0.5402563551042172, 2.898108925919669e-17, -0.4732230675449835],
         [-0.5523640315881179, 2.811060335110381e-17, -0.45900681245112573],
         [-0.5640305971829108, 2.7217796546904837e-17, -0.4444261563025453],
         [-0.575335915144953, 2.630801027836206e-17, -0.4295682118477999],
         [-0.586282388353527, 2.538165165114628e-17, -0.4144396485464787],
         [-0.5967470656639576, 2.443464667161036e-17, -0.39897388036939935],
         [-0.6068427740228688, 2.347298219445621e-17, -0.3832687067753213],
         [-0.616570806773389, 2.2496975894361343e-17, -0.36732931371226707],
         [-0.6258216887939452, 2.1503730556440226e-17, -0.351108385558242],
         [-0.6346977037597139, 2.0497956717099997e-17, -0.3346828524172],
         [-0.6431989454573126, 1.9479904720662045e-17, -0.31805680272159],
         [-0.6511810563271991, 1.8446217836868905e-17, -0.3011754142121688],
         [-0.6587791612576919, 1.7401937024917046e-17, -0.28412101412302465],
         [-0.6659911581316683, 1.6347237826023767e-17, -0.2668964692050228],
         [-0.6726813860842611, 1.5279727602981525e-17, -0.24946270427708261],
         [-0.6789766296861943, 1.420344118373564e-17, -0.23188561315928177],
         [-0.6848728058528742, 1.3118517279535426e-17, -0.2141674611548622],
         [-0.6902325390487584, 1.2023209262116127e-17, -0.19627972377070854],
         [-0.6951747516141558, 1.0920771206732719e-17, -0.17827554402085524],
         [-0.6996942786706174, 9.81133652885942e-18, -0.1601571007479005],
         [-0.7036521720993594, 8.693906843663924e-18, -0.14190808909888047],
         [-0.7071956003928191, 7.571451299693695e-18, -0.12357699894669062],
         [-0.710318998133277, 6.44414006335067e-18, -0.10516660931991012],
         [-0.7139779529651757, 4.4954081543323836e-21, -0.07182311068925219],
         [-0.8558579024987216, 4.4954081543323836e-21, -0.07182311068925318],
         [-0.8558579024987216, 4.4954081543323836e-21, -0.14364699027171945],
         [-0.9995056616636551, 4.4954081543323836e-21, 7.688932141024849e-07],
         [-0.8558579024987216, 4.4954081543323836e-21, 0.1436485280581486],
         [-0.8558579024987216, 4.4954081543323836e-21, 0.0718246484756814],
         [-0.7122101433337859, 4.4954081543323836e-21, 0.0718246484756814],
         [-0.7101034965548036, -6.087697272171461e-18, 0.09949382574139899],
         [-0.7082609933364074, -7.217868082009019e-18, 0.11795091574685157],
         [-0.7048089309836327, -8.341556908886927e-18, 0.13630214693710566],
         [-0.7009373282025825, -9.459935799123431e-18, 0.15456666028111893],
         [-0.6966367036059375, -1.0572642193592239e-17, 0.17273853473902004],
         [-0.6917842782426681, -1.1676757680586674e-17, 0.19077010903069605],
         [-0.686532600584519, -1.2773838463269016e-17, 0.208686797882472],
         [-0.6808727724137313, -1.3863494389121935e-17, 0.22648222962020387],
         [-0.6746618705338245, -1.4941788450243546e-17, 0.24409210802551007],
         [-0.668061885450966, -1.6011214612727595e-17, 0.26155716265560613],
         [-0.6610601472264738, -1.7071237447790272e-17, 0.2788686492948676],
         [-0.653550871247968, -1.81181045706513e-17, 0.295965286849302],
         [-0.6456625847485462, -1.9154291160145213e-17, 0.3128874980568981],
         [-0.6373804162987747, -2.0179121203326025e-17, 0.32962424278842917],
         [-0.6286012846154017, -2.1188270255756177e-17, 0.34610489750671675],
         [-0.6194466195350301, -2.2184630432609215e-17, 0.36237669403689604],
         [-0.6098978896256366, -2.3167290157661624e-17, 0.37842474520947295],
         [-0.5998806484292324, -2.413223153555778e-17, 0.39418343381369686],
         [-0.5895058557948166, -2.508270659171159e-17, 0.4097058694549865],
         [-0.5787561849228763, -2.601769893300259e-17, 0.4249754531740134],
         [-0.5675471789092137, -2.6932185200998734e-17, 0.43991014730186906],
         [-0.555979224718831, -2.782949910597824e-17, 0.45456439545903937],
         [-0.5440281932445771, -2.870813647823441e-17, 0.4689136326900169],
         [-0.5316547599209588, -2.956445893308094e-17, 0.4828984396636322],
         [-0.5189553441601219, -3.04024733037141e-17, 0.4965842529318597],
         [-0.5059169129756561, -3.1221073975967847e-17, 0.5099530164451239],
         [-0.4924410227809405, -3.2012547273253943e-17, 0.5228787563047644],
         [-0.47865734876644245, -3.278364463613709e-17, 0.5354717319026262],
         [-0.4645472659737015, -3.3532665829235916e-17, 0.5477041762877382],
         [-0.45008843570187157, -3.4256186129132005e-17, 0.5595201594822365],
         [-0.4353580459528023, -3.4958609557437374e-17, 0.5709916046171855],
         [-0.4203406343995568, -3.563827146809781e-17, 0.5820913259594315],
         [-0.40499041061826413, -3.6289303114448846e-17, 0.5927234796024944],
         [-0.3893961769426973, -3.691794129828541e-17, 0.6029899202492878],
         [-0.37354047471344276, -3.752201320383706e-17, 0.6128551631253922],
         [-0.35742192509874365, -3.809924288992922e-17, 0.6222820392907339],
         [-0.3410954702265476, -3.8653832360352056e-17, 0.6313391726749704],
         [-0.32454901917886597, -3.918391779948583e-17, 0.6399961248591096],
         [-0.3077464896456647, -3.968265207379642e-17, 0.6481410736665159],
         [-0.29076569459111473, -4.0157922848708783e-17, 0.6559028344491882],
         [-0.27359496184751014, -4.0607417017327386e-17, 0.6632436313047645],
         [-0.2562376775958344, -4.10289917814683e-17, 0.6701284696832173],
         [-0.2387306173770215, -4.142622454112497e-17, 0.6766157729601012],
         [-0.2210608959521123, -4.1796211619078793e-17, 0.6826581204877552],
         [-0.20322769420629688, -4.2135178501536966e-17, 0.6881938697779854],
         [-0.185273761676981, -4.244885506307234e-17, 0.693316596783907],
         [-0.1671896739899633, -4.273404065583344e-17, 0.6979740309593714],
         [-0.14899003192378396, -4.2989807641487775e-17, 0.7021510228207365],
         [-0.1307000956866102, -4.321936016851491e-17, 0.7058999000837464],
         [-0.11231314915482549, -4.34192438423744e-17, 0.709164248204342],
         [-0.09383953019484811, -4.3585653831766976e-17, 0.7110124576717894],
         [-0.07182162976344943, 4.4954081543323836e-21, 0.7131249160686077],
         [-0.07182162976344943, 4.4954081543323836e-21, 0.8561838026611327],
         [-0.14364550934591674, 4.4954081543323836e-21, 0.8561838026611327],
         [2.249819017971722e-06, 4.4954081543323836e-21, 0.9998315618260656],
         [0.14365000898395247, 4.4954081543323836e-21, 0.8561838026611327],
         [0.07182612940148543, 4.4954081543323836e-21, 0.8561838026611327],
         [0.07182612940148543, 4.4954081543323836e-21, 0.7131249160686077],
         [0.09232083450553186, -4.3599039927352754e-17, 0.7112732254161431],
         [0.11079918269794695, -4.343375234838748e-17, 0.7094011900887],
         [0.1291884393001287, -4.323543623750627e-17, 0.706162442214306],
         [0.1474948338640772, -4.301075279399389e-17, 0.7024930831196047],
         [0.1656995660937379, -4.2755898344792564e-17, 0.6983309941094709],
         [0.1837846383385905, -4.247141882159778e-17, 0.6936850909250928],
         [0.20176127113327005, -4.216257850250993e-17, 0.6886413457521513],
         [0.21961388354134048, -4.1827078311952345e-17, 0.6831622118371197],
         [0.23728288350866575, -4.145741300376667e-17, 0.6771251192085517],
         [0.25481206208438073, -4.106371923580243e-17, 0.6706956120520611],
         [0.27218045261861523, -4.0643650424946294e-17, 0.6638353677571813],
         [0.2893586016056411, -4.019547615953293e-17, 0.6565161265567881],
         [0.3063666222763842, -3.972387325320081e-17, 0.6488142666138033],
         [0.32317209651097223, -3.922523300930867e-17, 0.6406708534395305],
         [0.339731055644015, -3.869692234186699e-17, 0.6320428854768434],
         [0.3560926054939187, -3.814614407463974e-17, 0.6230479937643268],
         [0.37222646494855166, -3.757034428649845e-17, 0.6136444696045714],
         [0.3880938235437077, -3.6967647079408015e-17, 0.6038016772581842],
         [0.4037309563377685, -3.6342980760639236e-17, 0.5936001020903284],
         [0.4190949085494181, -3.569296651756439e-17, 0.5829845638998766],
         [0.4341338764953483, -3.5015339507127356e-17, 0.5719180750092004],
         [0.448911067167519, -3.431654980922522e-17, 0.5605059731973865],
         [0.46338530599337024, -3.359402941446065e-17, 0.5487063196779216],
         [0.4775051187044391, -3.284590736554943e-17, 0.5364885594146181],
         [0.49132980570942875, -3.2077523459593323e-17, 0.5239398979422069],
         [0.5048084106839476, -3.1286053765402596e-17, 0.5110142170958144],
         [0.5178780570629408, -3.046954636132539e-17, 0.49767963900359674],
         [0.5306298839314281, -2.9634453739276995e-17, 0.4840415413746517],
         [0.5430208106482807, -2.8778949846680915e-17, 0.47007010284058737],
         [0.5549910459715933, -2.7901490617731014e-17, 0.4557401062617147],
         [0.5666223746094745, -2.7007178851966142e-17, 0.4411348867297319],
         [0.5778622280471271, -2.6093997688563706e-17, 0.4262215078864688],
         [0.5886393783723654, -2.516037872225527e-17, 0.4109743480468314],
         [0.5990644468463835, -2.42119022416345e-17, 0.39548455105284286],
         [0.6090952111055409, -2.324738651593775e-17, 0.3797328238929749],
         [0.6186662072784886, -2.2265703732692736e-17, 0.3637007448415196],
         [0.627877172356834, -2.127122630353832e-17, 0.34745968732313603],
         [0.6366808614641742, -2.026279712540406e-17, 0.3309905807522763],
         [0.6449904356921378, -1.9238942346359936e-17, 0.31427009606888806],
         [0.652927817545072, -1.8204086835430034e-17, 0.29736978957530297],
         [0.6604516561462216, -1.715754848071208e-17, 0.280278189502196],
         [0.6674847982101083, -1.6098514334581373e-17, 0.2629818594900687],
         [0.674143715405849, -1.50303989394191e-17, 0.24553821602796122],
         [0.6804045691358974, -1.3952659666794092e-17, 0.2279443931617514],
         [0.6860798685037115, -1.2864068559293838e-17, 0.21015687591052856],
         [0.6913656243657678, -1.1767894533321676e-17, 0.19224897435954677],
         [0.6963078955666434, -1.066296532535281e-17, 0.1742394069382137],
         [0.7005347458787325, -9.55304272027608e-18, 0.15605599426428968],
         [0.7043918301579966, -8.436053328319361e-18, 0.1377793594104616],
         [0.7086930922042123, -7.294423440342042e-18, 0.1196237269495816],
         [0.7097304006221763, -6.204756528444624e-18, 0.10077802993805608],
         [0.7131083084219872, 4.4954081543323836e-21, 0.07182464847568246],
         [0.8567560675869216, 4.4954081543323836e-21, 0.07182464847568246],
         [0.8567560675869216, 4.4954081543323836e-21, 0.14364852805814995],
         [1.000403826751859, 4.4954081543323836e-21, 7.688932151231638e-07],
         [0.8567560675869216, 4.4954081543323836e-21, -0.14364699027171945],
         [0.8567560675869216, 4.4954081543323836e-21, -0.07182311068925219],
         [0.7131083084219872, 4.4954081543323836e-21, -0.07182311068925219],
         [0.708722590618041, 6.508670168317373e-18, -0.10528631250836548],
         [0.7064419060540527, 7.58793699591616e-18, -0.12339333471294958],
         [0.7036523274518477, 8.696114566406692e-18, -0.1419543469692213],
         [0.7001433111365613, 9.802727257137853e-18, -0.16027156582054655],
         [0.6951538953132701, 1.0921201461136248e-17, -0.17826955387725682],
         [0.6900873760985506, 1.2026081083442728e-17, -0.19624127298397945],
         [0.6849307255678295, 1.311781142375181e-17, -0.21418727467184395],
         [0.6789878621119937, 1.4203495165434265e-17, -0.23189051791029433],
         [0.6726814857263902, 1.5279923315569483e-17, -0.24946360155208466],
         [0.665991453020398, 1.634739005093202e-17, -0.2668974094780641],
         [0.6587832574887375, 1.740207731293927e-17, -0.28412359700934114],
         [0.6511861166414, 1.8446349383593318e-17, -0.30117835756224465],
         [0.6432015496809596, 1.9480041140217602e-17, -0.3180586151640961],
         [0.6347008744402949, 2.0498090251450923e-17, -0.3346849466164433],
         [0.625825052884126, 2.1503862445310485e-17, -0.35111058337460604],
         [0.6165742058291214, 2.2497106567100608e-17, -0.3673315323406521],
         [0.6068459404370045, 2.3473110543324713e-17, -0.38327078135569387],
         [0.5967501342401732, 2.443477284610771e-17, -0.3989758955306308],
         [0.5862855161506727, 2.5381775974444852e-17, -0.4144417019657607],
         [0.5753389608145881, 2.6308132054075142e-17, -0.429570206403751],
         [0.5640335739026898, 2.7217915563604288e-17, -0.4444280983668205],
         [0.5523669490867575, 2.811071963628483e-17, -0.4590087068777064],
         [0.5402592292888047, 2.898120297731666e-17, -0.473224925332833],
         [0.5278119969813545, 2.9833275272132993e-17, -0.48714014067374223],
         [0.5150237132057961, 3.0666540199875267e-17, -0.5007477133234475],
         [0.5017876916487845, 3.1473005163888797e-17, -0.5139197060634855],
         [0.4882374155153429, 3.2259441314071075e-17, -0.5267632938489574],
         [0.4743693220473693, 3.302522649932876e-17, -0.5392686372669097],
         [0.46014081229572595, 3.37659304770838e-17, -0.5513619540248029],
         [0.4456202893407636, 3.4484361262685875e-17, -0.563097158891264],
         [0.43080366805496506, 3.517975337078781e-17, -0.5744629778810559],
         [0.4156458793198201, 3.584788621773989e-17, -0.5853685432471336],
         [0.4002350021157505, 3.6493725493083256e-17, -0.5959078929708035],
         [0.38456728994320033, 3.7115568286743994e-17, -0.6060682560924087],
         [0.3686222754871191, 3.771538527312899e-17, -0.6157868587625557],
         [0.35245361721991325, 3.828042876140546e-17, -0.6251219580702674],
         [0.3360581526944811, 3.879809969884935e-17, -0.6340609323222048],
         [0.31939533440484036, 3.9383621751893485e-17, -0.6424889470086936],
         [0.30255103999403216, 3.987968178912845e-17, -0.6505426390180186],
         [0.28552099890769184, 4.031692760241432e-17, -0.6582026679594813],
         [0.26830429006238105, 4.048650017295732e-17, -0.6654346056094138],
         [0.2509092589550268, 4.1106139793236354e-17, -0.6722125677539225],
         [0.2333317288380462, 4.252187942178411e-17, -0.6785204431140072],
         [0.21555938310462627, 4.142247794831148e-17, -0.6842444761639082],
         [0.1977105982940524, 4.1243678058398196e-17, -0.689733951999861],
         [0.17978777606106444, 4.2048113803532293e-17, -0.6949590108787613],
         [0.16174217253160061, 4.438642454105753e-17, -0.6998027165032189],
         [0.1434651010536516, 4.5393681464816715e-17, -0.7035110337630863],
         [0.12501521300043517, 4.497068025544718e-17, -0.7063358327147998],
         [0.10613646184823812, 3.424160006334484e-17, -0.7089322732981522],
         [0.0883883748395849, 2.084429443409713e-17, -0.7108334068614973],
         [0.07182612940148561, 4.4954081543323836e-21, -0.7122290885643646],
         [0.07182612940148564, 4.4954081543323836e-21, -0.8558768477293006],
         [0.14365000898395272, 4.4954081543323836e-21, -0.8558768477293006],
         [2.2498190184895382e-06, 4.4954081543323836e-21, -0.9995246068942343]]
CIRCLE = [[1.006715677346795, -0.0006702548752642524, -3.694798373504726e-15],
          [0.9942995854608142, -0.15846311195050425, -3.5110803153770576e-15],
          [0.957352671256412, -0.31236840627503687, -3.4555691641457997e-15],
          [0.8967790190942225, -0.4585990289160014, -3.2890357104520263e-15],
          [0.8140753908601714, -0.593558733194448, -3.4416913763379853e-15],
          [0.7112809990565734, -0.7139124523578333, -3.552713678800501e-15],
          [0.5909272798931885, -0.816706844161434, -3.524958103184872e-15],
          [0.45596757561474005, -0.8994104723954811, -3.58046925441613e-15],
          [0.309736952973776, -0.9599841245576726, -3.552713678800501e-15],
          [0.15583165864924373, -0.9969310387620733, -3.552713678800501e-15],
          [-0.001961198425996145, -1.009347130648053, -3.552713678800501e-15],
          [-0.15975405550123625, -0.9969310387620733, -3.552713678800501e-15],
          [-0.31365934982576843, -0.9599841245576726, -3.552713678800501e-15],
          [-0.45988997246673363, -0.8994104723954811, -3.58046925441613e-15],
          [-0.59484967674518, -0.8167068441614339, -3.4139358007223564e-15],
          [-0.7152033959085659, -0.7139124523578333, -3.552713678800501e-15],
          [-0.8179977877121639, -0.5935587331944481, -3.7192471324942744e-15],
          [-0.9007014159462143, -0.45859902891600135, -3.4416913763379853e-15],
          [-0.9612750681084048, -0.31236840627503687, -3.3584246494910985e-15],
          [-0.9982219823128072, -0.15846311195050422, -3.427813588530171e-15],
          [-1.0106380741987873, -0.0006702548752642523, -3.462480952995395e-15],
          [-0.9982219823128072, 0.15712260219997573, -3.4139358007223564e-15],
          [-0.9612750681084048, 0.3110278965245084, -3.2751579226442118e-15],
          [-0.9007014159462143, 0.45725851916547167, -3.3584246494910985e-15],
          [-0.8179977877121639, 0.5922182234439194, -3.552713678800501e-15],
          [-0.7152033959085659, 0.712571942607305, -3.3584246494910985e-15],
          [-0.59484967674518, 0.8153663344109039, -3.164135620181696e-15],
          [-0.45988997246673363, 0.8980699626449538, -3.469446951953614e-15],
          [-0.31365934982576843, 0.9586436148071453, -3.552713678800501e-15],
          [-0.15975405550123625, 0.9955905290115453, -3.469446951953614e-15],
          [-0.001961198425996145, 1.008006620897526, -3.3861802251067274e-15],
          [0.15583165864924373, 0.9955905290115453, -3.469446951953614e-15],
          [0.309736952973776, 0.9586436148071452, -3.497202527569243e-15],
          [0.45596757561474005, 0.8980699626449536, -3.4139358007223564e-15],
          [0.5909272798931885, 0.815366334410904, -3.3584246494910985e-15],
          [0.7112809990565734, 0.712571942607305, -3.469446951953614e-15],
          [0.8140753908601714, 0.5922182234439194, -3.4416913763379853e-15],
          [0.8967790190942225, 0.45725851916547183, -3.1780134079895106e-15],
          [0.957352671256412, 0.31102789652450846, -3.427813588530171e-15],
          [0.9942995854608142, 0.15712260219997573, -3.5110803153770576e-15],
          [1.006715677346795, -0.0006702548752642524, -3.694798373504726e-15]]
STAR = [[0.29029436932199354, 4.354415539829906, -6.661338147750939e-16],
        [0.0, 5.902652176213871, -1.1102230246251565e-15], [-0.29029436932199354, 4.354415539829906, -6.661338147750939e-16],
        [-0.43544155398299034, 3.918973985846915, -3.3306690738754696e-16],
        [-0.7741183181919832, 2.9513260881069354, -5.551115123125783e-16],
        [-1.1127950824009758, 2.322354954575948, -8.881784197001252e-16],
        [-1.5966190312709652, 1.5966190312709654, 5.551115123125783e-17],
        [-2.3223549545759483, 1.1127950824009756, -5.551115123125783e-17],
        [-2.9997084829939347, 0.7741183181919832, -2.498001805406602e-16],
        [-3.870591590959915, 0.4354415539829902, 2.7755575615628914e-17],
        [-4.402797934716903, 0.2902943693219935, -1.1102230246251565e-16],
        [-5.757504991552873, 0.0, 0.0], [-4.402797934716903, -0.2902943693219935, 1.1102230246251565e-16],
        [-3.870591590959915, -0.4354415539829902, -2.7755575615628914e-17],
        [-2.9997084829939347, -0.7741183181919832, 2.498001805406602e-16],
        [-2.3223549545759483, -1.1127950824009756, 5.551115123125783e-17],
        [-1.5966190312709652, -1.5966190312709654, -5.551115123125783e-17],
        [-1.1127950824009758, -2.322354954575948, 8.881784197001252e-16],
        [-0.7741183181919832, -2.9997084829939347, 2.220446049250313e-16],
        [-0.43544155398299034, -3.8705915909599153, -3.3306690738754696e-16],
        [-0.29029436932199354, -4.402797934716903, 4.440892098500626e-16],
        [0.0, -5.757504991552872, 4.440892098500626e-16],
        [0.29029436932199354, -4.402797934716903, 4.440892098500626e-16],
        [0.43544155398299034, -3.8705915909599153, -3.3306690738754696e-16],
        [0.7741183181919832, -2.9997084829939347, 2.220446049250313e-16],
        [1.1127950824009758, -2.322354954575948, 8.881784197001252e-16],
        [1.5966190312709652, -1.5966190312709654, -5.551115123125783e-17],
        [2.3223549545759483, -1.1127950824009756, 5.551115123125783e-17],
        [2.9997084829939347, -0.7741183181919832, 2.498001805406602e-16],
        [3.870591590959915, -0.4354415539829902, -2.7755575615628914e-17],
        [4.402797934716903, -0.2902943693219935, 1.1102230246251565e-16], [5.757504991552873, 0.0, 0.0],
        [4.402797934716903, 0.2902943693219935, -1.1102230246251565e-16],
        [3.870591590959915, 0.4354415539829902, 2.7755575615628914e-17],
        [2.9997084829939347, 0.7741183181919832, -2.498001805406602e-16],
        [2.3223549545759483, 1.1127950824009756, -5.551115123125783e-17],
        [1.5966190312709652, 1.5966190312709654, 5.551115123125783e-17],
        [1.1127950824009758, 2.322354954575948, -8.881784197001252e-16],
        [0.7741183181919832, 2.9513260881069354, -5.551115123125783e-16],
        [0.48382394886998936, 3.7254444062989176, -1.1102230246251565e-16],
        [0.29029436932199354, 4.354415539829906, -6.661338147750939e-16],
        [0.29029436932199354, 4.354415539829906, -6.661338147750939e-16],
        [0.29029436932199354, 4.354415539829906, -6.661338147750939e-16],
        [0.29029436932199354, 4.354415539829906, -6.661338147750939e-16]]
HEAD = [[0.3134548529969644, 0.3832924032745859, -0.3152986673102934],
                  [0.31529866731029377, 0.3360222346721657, -0.630051319606781],
                  [0.31529866731029377, 0.26741051513098685, -0.8995830490055129],
                  [0.31529866731029377, 0.16902509695021153, -1.1523042060144555],
                  [0.31529866731029377, 0.05481977223390687, -1.3555011930861403],
                  [0.9458966776920379, 0.05481977223390687, -1.3555011930861403],
                  [0.6379820525300844, -0.07707309391199758, -1.586],
                  [0.31529866731029377, -0.22800029347081213, -1.7906659390182778],
                  [0.0, -0.3832924032745861, -1.9947875348653963], [-0.315, -0.23158419276007058, -1.787312632016371],
                  [-0.6338416639291067, -0.0771, -1.5861142119019576],
                  [-0.9458966776920379, 0.05481977223390687, -1.3555011930861403],
                  [-0.31529866731029377, 0.05481977223390687, -1.3555011930861403],
                  [-0.31529866731029377, 0.17136948133962632, -1.1481330702808925],
                  [-0.31529866731029377, 0.2684826102045054, -0.8967985751634485],
                  [-0.31529866731029377, 0.3395997142304458, -0.615921829602235],
                  [-0.31529866731029377, 0.38329240327458575, -0.31345485299696424],
                  [-0.6468311448639844, 0.3317735553459869, -0.31529866731029355],
                  [-0.8952044545971494, 0.26888620855474804, -0.3152986673102934],
                  [-1.1462395875226201, 0.17243363621956603, -0.3152986673102934],
                  [-1.3555011930861405, 0.05481977223390682, -0.3152986673102934],
                  [-1.3555011930861405, 0.05481977223390675, -0.9458966776920376],
                  [-1.5794075978981437, -0.08325140921828043, -0.6241637505377394],
                  [-1.7906659390182778, -0.2280002934708122, -0.3152986673102934],
                  [-2.0011356568392564, -0.383292403274586, 3.72291864215378e-16],
                  [-1.7906659390182778, -0.22800029347081213, 0.3152986673102942],
                  [-1.5794075978981437, -0.0732123014891907, 0.6469953548248211],
                  [-1.3555011930861405, 0.05481977223390677, 0.9458966776920382],
                  [-1.3555011930861405, 0.05481977223390679, 0.31529866731029405],
                  [-1.1462395875226201, 0.17243363621956623, 0.3152986673102944],
                  [-0.8951267420642444, 0.2689059745685519, 0.3152986673102942],
                  [-0.6145240176516689, 0.33980159787571057, 0.31529866731029405],
                  [-0.3134548529969644, 0.383292403274586, 0.3152986673102942],
                  [-0.31529866731029377, 0.33668042603781845, 0.6274516664408013],
                  [-0.31529866731029377, 0.2662865553887662, 0.9025016614369844],
                  [-0.31529866731029377, 0.16938493976562197, 1.1516639223194294],
                  [-0.31529866731029377, 0.0548197722339067, 1.3555011930861407],
                  [-0.9458966776920379, 0.0548197722339067, 1.3555011930861407],
                  [-0.611659128232076, -0.08911177890080542, 1.5863890452295863],
                  [-0.3250522659510998, -0.22342927607336366, 1.7875026861904622],
                  [0.0, -0.3832924032745861, 1.9947875348653978],
                  [0.31697860954336565, -0.2272130317244209, 1.7902824297044364],
                  [0.630413527586237, -0.08032249142918448, 1.5799318095062895],
                  [0.9458966776920379, 0.0548197722339067, 1.3555011930861407],
                  [0.31529866731029377, 0.0548197722339067, 1.3555011930861407],
                  [0.31529866731029377, 0.17733898644879728, 1.1335004760959282],
                  [0.31529866731029377, 0.26910633775121745, 0.8943354257509196],
                  [0.31529866731029377, 0.3389856162802023, 0.618347474270624],
                  [0.3134548529969644, 0.383292403274586, 0.3152986673102942],
                  [0.6159218296022356, 0.339599714230446, 0.3152986673102944],
                  [0.8994708726536662, 0.2674535949046621, 0.3152986673102942],
                  [1.119668320999891, 0.1826649979974522, 0.3152986673102942],
                  [1.3555011930861405, 0.05481977223390679, 0.31529866731029405],
                  [1.3555011930861405, 0.05481977223390677, 0.9458966776920382],
                  [1.5794075978981437, -0.0939955047730545, 0.601237877569438],
                  [1.7965738063530432, -0.25039248406639897, 0.26983447039648545],
                  [1.9947875348653963, -0.383292403274586, 3.72291864215378e-16],
                  [1.7906659390182778, -0.22644992843934572, -0.31860685604802624],
                  [1.5794075978981437, -0.08262092406001126, -0.6255088531181608],
                  [1.3555011930861405, 0.05481977223390675, -0.9458966776920376],
                  [1.3555011930861405, 0.05481977223390682, -0.3152986673102934],
                  [1.1424462022750939, 0.17389429395761305, -0.31529866731029327],
                  [0.8973729721457943, 0.2682614673663029, -0.3152986673102932],
                  [0.613805007782004, 0.3399054961534004, -0.3152986673102931],
                  [0.3134548529969644, 0.3832924032745859, -0.3152986673102934]]
SQUAREPLUS = [[-1.12558, 0.0, 0.0], [-1.0, 0.0, 0.0], [-1.0, 0.0, -1.0], [0.0, 0.0, -1.0], [0.0, 0.0, -1.12558],
              [0.0, 0.0, -1.0], [1.0, 0.0, -1.0], [1.0, 0.0, 0.0], [1.12558, 0.0, 0.0], [1.0, 0.0, 0.0],
              [1.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.12558], [0.0, 0.0, 1.0], [-1.0, 0.0, 1.0],
              [-1.0, 0.0, 0.0], [-1.12558, 0.0, 0.0], [-1.0, 0.0, 0.0]]
CUBE = [[-1.0, 1.0, 1.0], [-1.0, 1.0, -1.0], [1.0, 1.0, -1.0], [1.0, 1.0, 1.0], [-1.0, 1.0, 1.0], [-1.0, -1.0, 1.0],
        [-1.0, -1.0, -1.0], [-1.0, 1.0, -1.0], [-1.0, 1.0, 1.0], [-1.0, -1.0, 1.0], [1.0, -1.0, 1.0], [1.0, 1.0, 1.0],
        [1.0, 1.0, -1.0], [1.0, -1.0, -1.0], [1.0, -1.0, 1.0], [1.0, -1.0, -1.0], [-1.0, -1.0, -1.0]]

layout = 200
percentage = 0.01 * layout
on_selector = 0
on_side = 0
add_prefix = 'Path'

#**********************************************************************************************************************#
#                                                    UI                                                                #
#**********************************************************************************************************************#
def show_ui():
    snake_rig = 'Larian_Ui'
    pm.window(snake_rig, exists=True)
    if pm.window(snake_rig, exists=True):
        pm.deleteUI(snake_rig)
    with pm.window(snake_rig, title='Larian Rig Test Adien', width=layout, height=200):
        with pm.columnLayout('Create_Column', w=layout*1.06, co=('both', 1 * percentage), adj=1):
            # ADDITIONAL
            pm.separator(h=8, st=None, w=90 * percentage)
            with pm.rowLayout(nc=2, cw2=(85 * percentage, 15 * percentage), cl2=('right','right'),
                              columnAttach=[(1, 'both', 0),(2, 'both', 0)],
                              rowAttach=[(1, 'bottom', 0.5),(2, 'bottom', 0.5) ]):
                pm.button('Create_Template', l="Create Template Joint",
                          c=partial(Lr_Template))
                pm.button('Delete_Template', l="Del",  bgc=(0.5, 0, 0), c=partial(lr_delete_template))

            #pm.separator(h=8, st="in", w=90 * percentage)
            with pm.frameLayout(collapsable=True, l='Create Rig', mh=3):
                with pm.columnLayout('Path', w=layout * 1.04, co=('both', 1 * percentage), adj=1):
                    pm.textFieldGrp('Prefix_Name', label='Prefix Name:', cal=(1, "right"),
                                          cw2=(40 * percentage, 40 * percentage, ),
                                          columnAttach=[(1, 'both', 0 * percentage),
                                                        (2, 'both', 0 * percentage),
                                                        ], tx='snake')

                    with pm.rowLayout(nc=2, cw2=(40 * percentage, 40 * percentage), cl2=('right', 'left'),
                                      columnAttach=[(1, 'both', 0.5 * percentage), (2, 'both', 0.5 * percentage)]):
                        pm.text('Body Skeleton:')
                        pm.intField('Body_Skeleton', value=20, minValue=5)

                    with pm.rowLayout(nc=2, cw2=(85 * percentage, 15 * percentage), cl2=('right','right'),
                                      columnAttach=[(1, 'both', 0),(2, 'both', 0)],
                                      rowAttach=[(1, 'top', 4),(2, 'top', 4) ]):
                        pm.button('Create_Rig', l="Create Rig", bgc=(0, 0.5, 0),
                                  c=partial(lr_create_rig))
                        pm.button('Delete_Rig', l="Del", bgc=(0.5, 0, 0),
                                  c=partial(lr_delete_rig))

            # pm.separator(h=8, st="in", w=90 * percentage)
            with pm.frameLayout(collapsable=True, l='Create Path', mh=3):
                with pm.columnLayout('CreatePath', w=layout * 1.04, co=('both', 1 * percentage), adj=1):
                    with pm.rowLayout(nc=2, cw2=(40 * percentage, 40 * percentage), cl2=('right', 'left'),
                                      columnAttach=[(1, 'both', 0.5 * percentage), (2, 'both', 0.5 * percentage)]):
                        pm.text('Path Size:')
                        pm.intField('Path_Size', value=80, minValue=10)
                    with pm.rowLayout(nc=3, columnAttach=[(1, 'right', 0), (2, 'left', 1 * percentage),
                                                          (3, 'left', 1 * percentage)],
                                      cw3=(40 * percentage, 16 * percentage, 16 * percentage)):
                        pm.text('Tip Position:')
                        direction_control_position = pm.radioCollection('Tip_Position')
                        direction_positve = pm.radioButton(label='+',
                                                           onCommand=lambda x: lr_create_path_on_pos_radio_button(1))
                        pm.radioButton(label='-', onCommand=lambda x: lr_create_path_on_pos_radio_button(2))
                        pm.radioCollection(direction_control_position, edit=True, select=direction_positve)

                    with pm.rowLayout(nc=3, columnAttach=[(1, 'right', 0), (2, 'left', 1 * percentage),
                                                          (3, 'left', 1 * percentage)],
                                      cw3=(40 * percentage, 16 * percentage, 16 * percentage)):
                        pm.text('Rig Direction:')
                        direction_control_translate = pm.radioCollection('Rig_Direction')
                        pm.radioButton(label='Tx', onCommand=lambda x: lr_create_path_on_selection_button(1))
                        direction_translateZ = pm.radioButton(label='Tz', onCommand=lambda x: lr_create_path_on_selection_button(3))
                        pm.radioCollection(direction_control_translate, edit=True, select=direction_translateZ)

                    with pm.rowLayout(nc=2, cw2=(85 * percentage, 15 * percentage), cl2=('right','right'),
                                      columnAttach=[(1, 'both', 0),(2, 'both', 0)],
                                      rowAttach=[(1, 'top', 4),(2, 'top', 4) ]):
                        pm.button('Create_Path', l="Create Path",
                                  c=partial(lr_create_path))
                        pm.button('Delete_Path', l="Del", bgc=(0.5, 0, 0),
                                  c=partial(lr_delete_path))
            with pm.frameLayout(collapsable=True, l='Attach Path', mh=3):
                with pm.columnLayout('AttachPath', w=layout * 1.04, co=('both', 1 * percentage), adj=1):
                    with pm.rowLayout(nc=2, cw2=(40 * percentage, 40 * percentage), cl2=('right', 'left'),
                                      columnAttach=[(1, 'both', 0.5 * percentage), (2, 'both', 0.5 * percentage)]):
                        pm.text('Start Frame:')
                        pm.intField('Start_Frame', value=0, minValue=0)

                    with pm.rowLayout(nc=2, cw2=(40 * percentage, 40 * percentage), cl2=('right', 'left'),
                                      columnAttach=[(1, 'both', 0.5 * percentage), (2, 'both', 0.5 * percentage)]):
                        pm.text('End Frame:')
                        pm.intField('End_Frame', value=500, minValue=0)

                    with pm.rowLayout(nc=2, cw2=(40 * percentage, 40 * percentage), cl2=('right', 'left'),
                                      columnAttach=[(1, 'both', 0.5 * percentage), (2, 'both', 0.5 * percentage)]):
                        pm.text('Speed:')
                        pm.floatField('Speed', value=1.0, minValue=0.1, pre=2)

                    with pm.rowLayout(nc=2, cw2=(40 * percentage, 40 * percentage), cl2=('right', 'left'),
                                      columnAttach=[(1, 'both', 0.5 * percentage), (2, 'both', 0.5 * percentage)]):
                        pm.text('')
                        pm.button('Reset_Value', l="Reset Value",
                                  c=partial(lr_reset_value))
                    # pm.separator(h=8, st="in", w=90 * percentage)

                    with pm.rowLayout(nc=2, cw2=(85 * percentage, 15 * percentage), cl2=('right','right'),
                                      columnAttach=[(1, 'both', 0),(2, 'both', 0)],
                                      rowAttach=[(1, 'top', 4),(2, 'top', 4) ]):
                        pm.button('Attach_To_Path', l="Attach To Path",
                                  c=partial(lr_attach_to_path))
                        pm.button('Reset', l="Res", bgc=(0.5, 0, 0),
                                  c=partial(lr_reset_attach))

                    pm.separator(h=8, st="in", w=90 * percentage)

                    with pm.rowLayout(nc=2, cw2=(50 * percentage, 50 * percentage), cl2=('right','right'),
                                      columnAttach=[(1, 'both', 0),(2, 'both', 0)],
                                      rowAttach=[(1, 'top', 4),(2, 'top', 4) ]):
                        pm.button('Load_Skin', l="Load Skin Weight",
                                  c=partial(lr_load_skin))
                        pm.button('Load_Ctrl', l="Load Ctrl Shape",
                                  c=partial(lr_load_ctrl))
                    pm.separator(h=8, st="in", w=90 * percentage)


    pm.showWindow()
#**********************************************************************************************************************#
#                                            CLASS TEMPLATE & RIG                                                      #
#**********************************************************************************************************************#
class Lr_Template():
    def __init__(self, *args):
        if mc.objExists('tmp_grp'):
            om.MGlobal.displayError('joint template already exist')
        else:
            self.body_base = self.joint_template(name_template='bodyBase_tmp', pos_x=0, pos_y=0, pos_z=111)
            self.body_tip = self.joint_template(name_template='bodyTip_tmp', pos_x=0, pos_y=0, pos_z=-132)
            self.head = self.joint_template(name_template='head_tmp', pos_x=0, pos_y=3.398, pos_z=112.608)
            self.upperJaw_joint = self.joint_template(name_template='upperJaw_tmp', pos_x=0, pos_y=3.6, pos_z=116.357)
            self.upperJaw_tip = self.joint_template(name_template='upperJawTip_tmp', pos_x=0, pos_y=3.6, pos_z=125.248)
            self.jaw_joint = self.joint_template(name_template='jaw_tmp', pos_x=0, pos_y=2.956, pos_z=115.01)
            self.jaw_tip = self.joint_template(name_template='jawTip_tmp', pos_x=0, pos_y=-4.005, pos_z=121.998)
            self.tongue = self.joint_template(name_template='tongue_tmp', pos_x=0, pos_y=1.137, pos_z=116.245)
            self.tongue_tip = self.joint_template(name_template='tongueTip_tmp', pos_x=0, pos_y=-7.289, pos_z=127.29)
            self.left_fang = self.joint_template(name_template='leftFang_tmp', pos_x=1, pos_y=3.402, pos_z=124.164)
            self.right_fang = self.joint_template(name_template='rightFang_tmp', pos_x=-1, pos_y=3.402, pos_z=124.164)

            # set orient
            mc.setAttr(self.jaw_joint +'.jointOrientX', 45)
            mc.setAttr(self.tongue +'.jointOrientX', 45)
            mc.setAttr(self.tongue_tip +'.jointOrientX', 45)

            # parent
            mc.parent(self.body_tip, self.body_base)
            mc.parent(self.jaw_tip, self.tongue, self.jaw_joint)
            mc.parent(self.tongue_tip, self.tongue)
            mc.parent(self.left_fang, self.right_fang, self.upperJaw_tip, self.upperJaw_joint)
            mc.parent(self.jaw_joint, self.upperJaw_joint,  self.head)
            # mc.parent(self.head, self.base)


            # group
            self.tmp_grp = mc.group(n='tmp_grp', empty=True)
            self.lock_node(self.tmp_grp)
            mc.parent(self.head, self.body_base, self.tmp_grp)

            # add message
            self.add_message(object_origin=self.tmp_grp, object_target=self.head, ln='head_jnt_msg')
            self.add_message(object_origin=self.tmp_grp, object_target=self.body_base, ln='bodyBase_jnt_msg')
            self.add_message(object_origin=self.tmp_grp, object_target=self.body_tip, ln='bodyTip_joint_msg')
            self.add_message(object_origin=self.tmp_grp, object_target=self.jaw_joint, ln='jaw_joint_msg')
            self.add_message(object_origin=self.tmp_grp, object_target=self.jaw_tip, ln='jaw_tip_msg')
            self.add_message(object_origin=self.tmp_grp, object_target=self.upperJaw_joint, ln='upperJaw_joint_msg')
            self.add_message(object_origin=self.tmp_grp, object_target=self.upperJaw_tip, ln='upperJaw_tip_msg')
            self.add_message(object_origin=self.tmp_grp, object_target=self.tongue, ln='tongue_msg')
            self.add_message(object_origin=self.tmp_grp, object_target=self.tongue_tip, ln='tongue_tip_msg')
            self.add_message(object_origin=self.tmp_grp, object_target=self.left_fang, ln='left_fang_msg')
            self.add_message(object_origin=self.tmp_grp, object_target=self.right_fang, ln='right_fang_msg')


    def joint_template(self, name_template, pos_x, pos_y, pos_z):
        mc.select(cl=1)
        joint_tmp = mc.joint(name=name_template, rad=0.5, p=(pos_x, pos_y, pos_z))
        mc.setAttr(joint_tmp+'.type', 18)
        mc.setAttr(joint_tmp+'.drawLabel', 1)
        mc.setAttr(joint_tmp+'.otherType', name_template, type='string')
        mc.setAttr(joint_tmp+'.ove', 1)
        mc.setAttr(joint_tmp+'.ovc', 17)

        return joint_tmp

    def lock_node(self, object):
        mc.lockNode(object, lock=True)

    def add_message(self, object_origin, object_target, ln=''):
        mc.addAttr(object_target, ln=ln, at='message')
        mc.connectAttr(object_origin + '.message', '%s.%s' % (object_target, ln))

class Lr_RigUI():
    def __init__(self):
        self.prefix_name = pm.textFieldGrp( "Prefix_Name", query=True, text=True )
        self.body_skeleton = pm.intField("Body_Skeleton", query=True, value=True)
        self.path_size = pm.intField("Path_Size", query=True, value=True)
        self.start_frame = pm.intField('Start_Frame', query=True, value=True)
        self.end_frame = pm.intField('End_Frame', query=True, value=True)
        self.speed = pm.floatField('Speed', query=True, value=True)

        # self.tip_position = pm.radioCollection('Tip_Position', query=True, select=True)

        self.rig_direction = lr_create_path_action_translate_radio_button()
        self.tip_position = lr_create_path_action_pos_radio_button()

    def set_prefix_name(self, prefix_name):
        self.prefix_name = prefix_name
        pm.textFieldGrp( "Prefix_Name", edit=True, text=prefix_name )

    def set_body_skeleton(self, skeleton_number):
        self.prefix_name = skeleton_number
        pm.intField( "Body_Skeleton", edit=True, value=skeleton_number )

    def set_path_size(self, path_size):
        self.path_size = path_size
        pm.intField( "Path_Size", edit=True, value=path_size )

    def set_start_frame(self, start_frame):
        self.start_frame = start_frame
        pm.intField( "Start_Frame", edit=True, value=start_frame )

    def set_end_frame(self, end_frame):
        self.end_frame = end_frame
        pm.intField( "Start_Frame", edit=True, value=end_frame )

    def set_speed(self, speed):
        self.speed = speed
        pm.floatField( "Speed", edit=True, value=speed )

    def set_rig_direction(self, rig_direction):
        self.rig_direction = rig_direction
        pm.radioCollection('Tip_Position', query=True, select=rig_direction)

class Lr_Control():
    def __init__(self, match_obj_second_position=None, match_obj_first_position=False,
                 prefix=None, suffix='ctrl', groups_ctrl=['Zro'],
                 group_connect_attr=[''], ctrl_size=5.0, ctrl_color='turquoiseBlue',
                 lock_channels=['v'],  shape=CIRCLE, connection=''):


        scale_controller =  lr_scale_curve(ctrl_size, shape)
        ctrl = lr_controller_shape(scale_controller)

        rename_controller = mc.rename(ctrl, '%s_%s' % (lr_prefix_name(prefix), suffix))

        # get the number
        try:
            patterns = [r'\d+']
            prefix_number =lr_prefix_name(prefix)
            for p in patterns:
                prefix_number = re.findall(p, prefix_number)[0]
        except:
            prefix_number = ''

        # get the prefix without number
        prefix_without_number = str(lr_prefix_name(prefix)).translate(None, digits)

        group_parent = lr_group_parents(groups=groups_ctrl, prefix=prefix_without_number, number=prefix_number,
                                       suffix=suffix.title(),
                                       )

        parent_controller = mc.parent(rename_controller, group_parent[-1])

        lr_set_color(rename_controller, ctrl_color)

        # lock and hide attribute
        lr_lock_hide_attr(lock_channels, rename_controller)

        connection_controller = rename_controller

        if match_obj_first_position:
            mc.delete(mc.parentConstraint(match_obj_first_position, match_obj_second_position, group_parent[0]))

        # connection to attribute
        if connection == ['connectAttr']:
            group_connection =  lr_group_object(group_connect_attr, match_obj_first_position, connection_controller)
            connection =  lr_connections(connection, rename_controller, match_obj_first_position)

        # connection parent
        elif connection == ['parent']:
            # query list relatives
            list_relatives_parent = mc.listRelatives(match_obj_first_position, p=1)

            if list_relatives_parent == None:
                connection =  lr_connections(connection, connection_controller, match_obj_first_position)

            else:
                # parent object to controller
                connection =  lr_connections(connection, connection_controller, match_obj_first_position)

                # parent ctrl group to list relatives
                mc.parent(group_parent[0],list_relatives_parent)

        # connection constraint
        else:
            connection =  lr_connections(connection, connection_controller, match_obj_first_position)

        # clear selection
        mc.select(cl=1)

        self.control = rename_controller
        self.parent_control = group_parent
        self.connection = connection

class Lr_GeneralBase:
    # top structure
    def __init__(self,
                 lockChannels=['t', 'r', 's'], prefix='', color_world='darkGreen',
                 color_place='yellow',
                 scale=1.0
                 ):
        """
        @param lockChannels: str, list attribute channels
        @param scale       : float, scale general all object base
        @return            : None

        """
        # make world control
        world_control = Lr_Control(
            prefix='World%s' % prefix,
            suffix='Ctrl',
            groups_ctrl=['Zro'],
            ctrl_size=scale * 5,
            ctrl_color=color_world,
            lock_channels=['v'],
            shape=CIRCLE,
        )

        # make placer control
        place_control = Lr_Control(
            prefix='Place%s' % prefix,
            suffix='Ctrl',
            groups_ctrl=['Zro'],
            ctrl_size=scale * 5,
            ctrl_color=color_place,
            lock_channels=['v'],
            shape=WORLD,
        )

        # create group and parenting corresponding to its grp
        self.root_grp = mc.group(n='Rig%s_Grp' % prefix, em=1)
        self.world_grp = mc.group(n='World%s_Grp' % prefix, em=1, p=self.root_grp)
        mc.parent(world_control.control, self.world_grp)

        self.place_grp = mc.group(n='Place%s_Grp' % prefix, em=1, p=world_control.control)
        mc.parent(place_control.control, self.place_grp)

        self.anim_grp = mc.group(n='anim%s_grp' % prefix, em=1, p=place_control.control)

        self.util_grp = mc.group(n='Utils%s_Grp' % prefix, em=1, p=self.world_grp)

        # deleting grp parent ctrl
        mc.delete(world_control.parent_control[0])
        mc.delete(place_control.parent_control[0])

        # create more group for other utilities
        self.anim_util_grp = mc.group(n='Anim%s_Grp' % prefix, em=1, p=self.util_grp)

        self.joint_grp = mc.group(n='Joint%s_Grp' % prefix, em=1, p=self.anim_util_grp)
        self.curve_grp = mc.group(n='Curve%s_Grp' % prefix, em=1, p=self.anim_util_grp)
        self.surface_grp = mc.group(n='Surface%s_Grp' % prefix, em=1, p=self.anim_util_grp)
        self.locator_grp = mc.group(n='Locator%s_Grp' % prefix, em=1, p=self.anim_util_grp)
        self.ik_handle_grp = mc.group(n='IkHandle%s_Grp' % prefix, em=1, p=self.anim_util_grp)
        self.cluster_grp = mc.group(n='Cluster%s_Grp' % prefix, em=1, p=self.anim_util_grp)

        self.still_grp = mc.group(n='Still%s_Grp' % prefix, em=1, p=self.util_grp)

        self.geo_grp = mc.group(n='Geo%s_Grp' % prefix, em=1, p=self.root_grp)

        # locking the atributes directories
        lr_lock_hide_attr(lockChannels, self.util_grp)
        lr_lock_hide_attr(lockChannels, self.joint_grp)
        lr_lock_hide_attr(lockChannels, self.curve_grp)
        lr_lock_hide_attr(lockChannels, self.surface_grp)
        lr_lock_hide_attr(lockChannels, self.locator_grp)
        lr_lock_hide_attr(lockChannels, self.ik_handle_grp)
        lr_lock_hide_attr(lockChannels, self.cluster_grp)

        mc.hide(self.joint_grp, self.surface_grp, self.locator_grp, self.ik_handle_grp, self.cluster_grp)

#**********************************************************************************************************************#
#                                            COMMAND FOR UI                                                            #
#**********************************************************************************************************************#
def lr_create_template(*args):
    if mc.objExists('tmp_grp'):
        mc.select('tmp_grp')
        om.MGlobal.displayError('Template already exists!')
    else:
        Lr_Template()

def lr_delete_template(*args):
    if mc.objExists('tmp_grp'):
        mc.lockNode('tmp_grp', lock=False)
        mc.delete('tmp_grp')
    else:
        om.MGlobal.displayError('There is no template joint in the scene')

def lr_create_rig(*args):
    RigUI = Lr_RigUI()
    if mc.objExists('Rig%s_Grp' % RigUI.prefix_name.title()):
        om.MGlobal.displayError('Rig %s already exists. please delete the previous rig first' % RigUI.prefix_name)
    else:
        tmp_grp = 'tmp_grp'
        if mc.objExists(tmp_grp):
            mc.hide(tmp_grp)
            MainRig = Lr_GeneralBase(prefix=RigUI.prefix_name.title())
            # base to tip
            body = lr_create_rig_base_tip_final(prefix=RigUI.prefix_name, skeleton_number=RigUI.body_skeleton,
                                                anim_grp=MainRig.anim_grp, curve_grp=MainRig.curve_grp,
                                                still_rig_group=MainRig.still_grp)

            # head part
            head = lr_create_rig_head(prefix=RigUI.prefix_name)
            jaw = lr_create_rig_jaw(prefix=RigUI.prefix_name)
            upperJaw = lr_create_rig_upperJaw(prefix=RigUI.prefix_name)
            leftFang = lr_create_rig_left_fang(prefix=RigUI.prefix_name)
            rightFang = lr_create_rig_right_fang(prefix=RigUI.prefix_name)

            tongue = lr_create_rig_tongue(prefix=RigUI.prefix_name)

            # # parenting
            mc.parent(tongue['mainGrp'][0], jaw['ctrl'])
            mc.parent(leftFang['mainGrp'], rightFang['mainGrp'], upperJaw['ctrl'])
            mc.parent(upperJaw['mainGrp'], jaw['mainGrp'], head['ctrl'])
            mc.parent(head['mainGrp'], body['ctrl_joint'][0])

            # parent to general base
            mc.parent(body['list_jointIk'][0], head['joint'], jaw['joint'], upperJaw['joint'], leftFang['joint'],
                      rightFang['joint'],
                      tongue['joint'][0],
                      MainRig.joint_grp)
            mc.parent(body['group_joint'], MainRig.anim_grp)
            mc.parent(body['hdl_curve'], MainRig.curve_grp)
            mc.parent(body['spline_hdl'], MainRig.ik_handle_grp)

            mc.hide(MainRig.curve_grp)

        else:
            om.MGlobal.displayError('before create rig %s, please create template joint first.' % RigUI.prefix_name)

def lr_delete_rig(*args):
    RigUI = Lr_RigUI()
    if mc.objExists('Rig%s_Grp' % RigUI.prefix_name.title()):
        mc.delete('Rig%s_Grp' % RigUI.prefix_name.title())
        if mc.objExists('tmp_grp'):
            mc.setAttr('tmp_grp.visibility',1)
        else:
            pass
    else:
        om.MGlobal.displayError('There is no rig %s in the scene' % RigUI.prefix_name)

def lr_create_path(*args):
    RigUI = Lr_RigUI()
    if mc.objExists('Rig%s_Grp' % (RigUI.prefix_name.title())):
        if mc.objExists('Rig%s%s_Grp' % (RigUI.prefix_name.title(), add_prefix)):
            om.MGlobal.displayError('Path %s already exists. please delete the previous setup first' % RigUI.prefix_name)
        else:
            world_rig_grp = 'World%s_Grp' % (RigUI.prefix_name.title())
            world_rig_ctrl = 'World%s_Ctrl' % (RigUI.prefix_name.title())
            lr_create_path_setup(parallel_axis=RigUI.rig_direction, prefix=RigUI.prefix_name, tip_pos=RigUI.tip_position,
                             path_size=RigUI.path_size, prefix_rig_name=RigUI.prefix_name.title(), world_rig_group=world_rig_grp,
                                 world_rig_ctrl=world_rig_ctrl)
    else:
        om.MGlobal.displayError('There is no rig %s in the scene, please create rig first before create path' % RigUI.prefix_name)

def lr_delete_path(*args):
    RigUI = Lr_RigUI()

    if mc.objExists('Rig%s%s_Grp' % (RigUI.prefix_name.title(), add_prefix)):
        mc.delete('Rig%s%s_Grp' % (RigUI.prefix_name.title(), add_prefix))

    else:
        om.MGlobal.displayError('There is no path %s setup in the scene' % RigUI.prefix_name)

def lr_attach_to_path(*args):
    RigUI = Lr_RigUI()
    world_up_loc = '%s%sAttach_loc' % (RigUI.prefix_name, add_prefix)
    if mc.objExists('Rig%s_Grp' % RigUI.prefix_name.title()) and mc.objExists('Rig%s%s_Grp' % (RigUI.prefix_name.title(), add_prefix)):
        if mc.objExists(world_up_loc):
            om.MGlobal.displayError('Path %s already exists. please delete the previous setup first' % RigUI.prefix_name)
        else:
            # query curve
            locator_grp = 'Locator%s%s_Grp' % (RigUI.prefix_name.title(), add_prefix)
            still_rig_group = 'Still%s_Grp' % (RigUI.prefix_name.title())
            still_path_group = 'Still%s%s_Grp' % (RigUI.prefix_name.title(), add_prefix)

            curve_grp = 'Curve%s_Grp' % RigUI.prefix_name.title()
            attr_curve_grp = mc.listAttr(curve_grp, ud=True)[0]
            curve = mc.listConnections(curve_grp + '.' + attr_curve_grp, d=1)[0]

            curve_attach_grp = 'Curve%s%s_Grp' % (RigUI.prefix_name.title(), add_prefix)
            attr_curve_path_grp = mc.listAttr(curve_attach_grp, ud=True)[0]
            curve_attach = mc.listConnections(curve_attach_grp + '.' + attr_curve_path_grp, d=1)[0]

            lr_path_line(curve_attach=curve_attach, curve=curve, prefix=RigUI.prefix_name,
                         path_size=RigUI.path_size, prefix_rig_name=RigUI.prefix_name.title(), rig_direction=RigUI.rig_direction,
                         start_frame=RigUI.start_frame, end_frame=RigUI.end_frame, locator_group=locator_grp,
                         still_rig_group=still_rig_group, still_path_group=still_path_group)
    else:
        om.MGlobal.displayError('Please create rig and create path %s first' % RigUI.prefix_name)

def lr_reset_attach(*args):
    RigUI = Lr_RigUI()
    world_up_loc = '%s%sAttach_loc' % (RigUI.prefix_name, add_prefix)
    if mc.objExists(world_up_loc):
        world_up_loc = '%s%sAttach_loc' % (RigUI.prefix_name, add_prefix)

        attr_locator = mc.listAttr(world_up_loc, ud=True)

        for mpt in attr_locator:
            object_mpt = mc.listConnections(world_up_loc + '.' + mpt, d=1)[0]
            print object_mpt
            mc.delete(object_mpt)

        mc.delete(world_up_loc)

        still_path_group = 'Still%s%s_Grp' % (RigUI.prefix_name.title(), add_prefix)
        attr = mc.listAttr(still_path_group, ud=True)

        # if attr:
        for att in attr:
            object_attr = mc.listConnections(still_path_group + '.' + att, d=1)[0]
            mc.delete(object_attr)

    else:
        om.MGlobal.displayError('There is no attach path %s setup' % RigUI.prefix_name)

    still_rig_group = 'Still%s_Grp' % (RigUI.prefix_name.title())
    attr_rig_group = mc.listAttr(still_rig_group, ud=True)
    anim_grp = 'anim%s_grp' % (RigUI.prefix_name.title())
    attr_anim = mc.listAttr(anim_grp, ud=True)

    for rig, anim in zip (attr_rig_group, attr_anim):
        grp_path_attach = mc.listConnections(still_rig_group + '.' + rig, d=1)[0]
        grp_anim = mc.listConnections(anim_grp + '.' + anim, d=1)[0]
        mc.delete(mc.parentConstraint(grp_path_attach, grp_anim))

def lr_reset_value(*args):
    RigUI = Lr_RigUI()
    world_up_loc = '%s%sAttach_loc' % (RigUI.prefix_name, add_prefix)
    if mc.objExists(world_up_loc):
        still_path_group = 'Still%s%s_Grp' % (RigUI.prefix_name.title(), add_prefix)
        attr = mc.listAttr(still_path_group, ud=True)
        for att in attr:
            object_attr = mc.listConnections(still_path_group + '.' + att, d=1)[0]
            nodes = mc.keyframe(object_attr, query=True, name=True)[0]
            if RigUI.start_frame >= RigUI.end_frame:
                om.MGlobal.displayError('Value start frame must be lower than end frame.')
            else:
                pm.keyframe(nodes, option='over', index=0, absolute=True, timeChange=RigUI.start_frame)
                pm.keyframe(nodes, option='over', index=1, absolute=True, timeChange=RigUI.end_frame/RigUI.speed)
    else:
        om.MGlobal.displayError('There is no attach path %s setup' % RigUI.prefix_name)

def lr_load_skin(*args):
    lr_readSelectedWeight(weightFolderPath='')

def lr_load_ctrl(*args):
    lr_readAllCtrl(search='', replace='')

#**********************************************************************************************************************#
#                                             CREATE PATH FUNCTION                                                     #
#**********************************************************************************************************************#
def lr_create_path_on_selection_button(on):
    # save the current shape selection into global variable
    global on_selector
    on_selector = on

def lr_create_path_action_translate_radio_button(*args):
    # value_translate, axis_translate = [], [],
    axis_translate=[]
    # query object with value on shape selector status
    if on_selector == 1:
        axis_translate = 'x'
    elif on_selector == 2:
        axis_translate = 'y'
    elif on_selector == 3:
        axis_translate = 'z'
    else:
        pass
    # value_translate = pm.getAttr('%s.%s' % (object, axis_translate))
    return axis_translate

def lr_create_path_on_pos_radio_button(on):
    # save the current shape selection into global variable
    global on_side
    on_side = on

def lr_create_path_action_pos_radio_button(*args):
    side = []
    if on_side == 1:
        side = '+'
    elif on_side == 2:
        side = '-'
    else:
        pass
    return side

def lr_create_path_setup(parallel_axis, prefix, tip_pos, path_size, prefix_rig_name, world_rig_group, world_rig_ctrl):
    # Check joint tmp
    if mc.objExists('tmp_grp'):
        list_tmp_jnt = lr_create_rig_sorted_joint_tmp()
        if mc.objExists(prefix + 'Main_geo'):
            om.MGlobal.displayError('Path already exists. Please delete the previous path first.')
        else:
            Main_Controller = Lr_GeneralBase(prefix=prefix_rig_name.title()+add_prefix, scale=8, color_world='red',
                 color_place='blue')

            skeleton = path_size
            size = float(skeleton)
            scale = skeleton / 2

            # Tip point dictionary towards
            tip_point_dic = {'+': [(size / 2.0 * -1) * scale, (size / 2.0) * scale],
                             '-': [(size / 2.0) * scale, (size / 2.0 * -1) * scale]}
            base_point = []
            tip_point = []
            if tip_pos in tip_point_dic.keys():
                pos = (0, 0, 0)
                base_point = tip_point_dic[tip_pos][0]
                tip_point = tip_point_dic[tip_pos][1]
            else:
                om.MGlobal.displayError('The string %s in tipPos argument is not found. Fill with + or -' % tip_pos)

            tmp_plane_dic = {'x': [(0, 1, 0), size * scale, (1.0 / size), size, 1],
                             'y': [(1, 0, 0), 1 * scale, size, 1, size/4],
                             'z': [(0, 1, 0), 1 * scale, size, 1, size/4]}

            # Create a NURBS-plane to use as a module
            tmp_plane = mc.nurbsPlane(axis=tmp_plane_dic[parallel_axis][0], width=tmp_plane_dic[parallel_axis][1],
                                      lengthRatio=tmp_plane_dic[parallel_axis][2], u=tmp_plane_dic[parallel_axis][3],
                                      v=tmp_plane_dic[parallel_axis][4], degree=3, ch=0)[0]

            # Create Joint reference
            mc.select(cl=1)
            create_joint = mc.joint(radius=scale / 5)

            # Duplicate joint from reference for skinning to the wire curve
            joint_path_base = mc.duplicate(create_joint, n=prefix + 'Base' + add_prefix + 'Tmp' + '_jnt')
            joint_path_tip = mc.duplicate(create_joint, n=prefix + 'Tip' + add_prefix + 'Tmp' + '_jnt')

            # Set the position for joints
            mc.setAttr((joint_path_base[0] + '.translate'), base_point, pos[1], pos[2])
            mc.setAttr((joint_path_tip[0] + '.translate'), tip_point, pos[1], pos[2])

            # create curve
            curve = lr_base_tip_jointFk_spline(base=joint_path_base, tip=joint_path_tip, prefix=prefix + add_prefix,
                                       skeleton_number=skeleton/2, spline_handle=False)
            # add message
            lr_add_message(object_origin=curve['hdl_curve'], object_target=Main_Controller.curve_grp, ln=curve['hdl_curve']+'_msg')

            # Grouping the joints to have rotation according to parallel axis
            grp_joint_orient = mc.group(joint_path_base[0], joint_path_tip[0], curve['hdl_curve'])

            # Set the rotation group joints
            if parallel_axis == 'z':
                mc.setAttr((grp_joint_orient + '.rotate'), 0, -90, 0)

            if parallel_axis == 'y':
                mc.setAttr((grp_joint_orient + '.rotate'), 0, 0, 90)

            mc.setAttr(tmp_plane + '.translate%s' % parallel_axis.title(), abs(base_point))
            mc.setAttr(grp_joint_orient + '.translate%s' % parallel_axis.title(), abs(base_point))

            # Create the NURBS-planes to use in the setup
            # geo_main_plane = mc.duplicate(tmp_plane, name=(prefix + 'Main_geo'))
            geo_Fk_plane = mc.duplicate(tmp_plane, name=(prefix + 'FkCurve' + '_geo'))
            geo_Ik_plane = mc.duplicate(tmp_plane, name=(prefix + 'IkCurve' + '_geo'))

            # Unparent from the group
            mc.parent(joint_path_base, joint_path_tip, curve['hdl_curve'], w=1)

            # Check joint tmp
            mc.delete(mc.orientConstraint(list_tmp_jnt[0], joint_path_base))
            mc.delete(mc.orientConstraint(list_tmp_jnt[0], joint_path_tip))

            # Create path joint
            path_connection = lr_create_path_joint(joint_path_base=joint_path_base, joint_path_tip=joint_path_tip,
                                                   prefix=prefix, skeleton=skeleton, add_prefix=add_prefix, anim_grp=Main_Controller.anim_grp)

            # Freezing rotation
            mc.makeIdentity(joint_path_base, apply=True, t=1, r=1, s=1, n=0, pn=1)
            mc.makeIdentity(joint_path_tip, apply=True, t=1, r=1, s=1, n=0, pn=1)
            # mc.makeIdentity(geo_main_plane, apply=True, t=1, r=1, s=1, n=0, pn=1)
            mc.makeIdentity(geo_Fk_plane, apply=True, t=1, r=1, s=1, n=0, pn=1)
            mc.makeIdentity(geo_Ik_plane, apply=True, t=1, r=1, s=1, n=0, pn=1)
            mc.makeIdentity(curve['hdl_curve'], apply=True, t=1, r=1, s=1, n=0, pn=1)

            # Follicle for Ik
            follicle_s = lr_item_follicle(path_connection[2], geo_Fk_plane, 'fol')

            for fol_s, group_ik_joint in zip(follicle_s['follicle'], path_connection[1]):
                lr_scale_constraint(Main_Controller.anim_grp, fol_s)
                mc.parent(fol_s, Main_Controller.cluster_grp)

                # Listing the shape of follicles
                follicle_listRelatives = mc.listRelatives(fol_s, s=1)[0]
                mc.setAttr(follicle_listRelatives + '.visibility', 0)

                # constraint
                lr_parent_constraint(fol_s, group_ik_joint)
                lr_scale_constraint(fol_s, group_ik_joint)

            # Skining joints to Fk
            mc.skinCluster(path_connection[3], geo_Fk_plane,
                           n='FkPathSkinCluster', tsb=True, bm=0, sm=0, nw=1, mi=5)
            geo_Fk_blendshape = mc.blendShape(geo_Fk_plane, geo_Ik_plane, name=(prefix + add_prefix +'Fk' + '_bsn'),
                                                weight=[(0, 1)])

            # Skining joints to Ik
            mc.skinCluster(path_connection[2], geo_Ik_plane,
                           n='IkPathSkinCluster', tsb=True, bm=0, sm=0, nw=1, mi=5)

            # connect bind pre matrix
            # connected the bind pre matrix
            for driver, joints in zip (path_connection[1], path_connection[2]):
                mc.connectAttr('%s.worldInverseMatrix[0]' % driver, '%s.bindPreMatrix[%d]' % (lr_query_skin_name(geo_Ik_plane),
                                                                                              lr_skin_matrix_list_from_joint(joints)))

            # parent to main group
            mc.parent(path_connection[0][0], path_connection[1], Main_Controller.anim_grp)
            mc.parent(path_connection[2], path_connection[3][0], Main_Controller.joint_grp)
            mc.parent(geo_Fk_plane, geo_Ik_plane, Main_Controller.surface_grp)
            mc.parent(curve['hdl_curve'], Main_Controller.curve_grp)

            # create isoparm
            curve_isoparm = mc.createNode('curveFromSurfaceIso', n=prefix+add_prefix+'_cfs')
            mc.setAttr(curve_isoparm+'.isoparmValue', 0.5)
            mc.setAttr(curve_isoparm+'.minValue', 0)
            mc.setAttr(curve_isoparm+'.maxValue', 16)

            if parallel_axis == 'z':
                mc.setAttr(curve_isoparm + '.isoparmDirection', 1)
            else:
                mc.setAttr(curve_isoparm + '.isoparmDirection', 0)

            # connect isoparm
            list_relatives_geo_Ik_plane = mc.listRelatives(geo_Ik_plane, s=True)[0]
            list_relatives_curve = mc.listRelatives(curve['hdl_curve'], s=True)[0]

            mc.connectAttr(list_relatives_geo_Ik_plane+'.worldSpace[0]', curve_isoparm+'.inputSurface')
            mc.connectAttr(curve_isoparm+'.outputCurve', list_relatives_curve+'.create')

            # make curve as reference mode
            mc.setAttr(list_relatives_curve+'.overrideEnabled', 1)
            mc.setAttr(list_relatives_curve+'.overrideDisplayType', 2)

            # parent main controller
            mc.parent(Main_Controller.root_grp, world_rig_group)

            # constraint from main rig
            lr_parent_constraint(world_rig_ctrl, Main_Controller.root_grp)
            lr_scale_constraint(world_rig_ctrl, Main_Controller.root_grp)

            # set inherit transform utils grp
            mc.setAttr(Main_Controller.util_grp+'.inheritsTransform', 0)

            # Delete the module surface and group rotation driver
            mc.delete(create_joint, tmp_plane, grp_joint_orient, joint_path_tip, joint_path_base, curve['list_jointIk'][0],
                      Main_Controller.geo_grp)

    else:
        om.MGlobal.displayError('Please create template joint before create path.' )

def lr_create_path_joint(joint_path_base, joint_path_tip, prefix, skeleton, add_prefix, anim_grp):
    joint_Ik = lr_create_rig_base_tip_joint_bind(base=joint_path_base, tip=joint_path_tip, prefix=prefix + add_prefix + 'Ik',
                                                 skeleton_number=skeleton / 2,
                                                 suffix='jnt', shape=CUBE, shape_2=CUBE, size=skeleton/16,
                                                 color='turquoiseBlue', color_2='turquoiseBlue', anim_grp=anim_grp)
    joint_Fk = lr_create_rig_base_tip_jointFk_spline(base=joint_path_base, tip=joint_path_tip, prefix=prefix + add_prefix + 'Fk',
                                                     skeleton_number=skeleton / 8, suffix='jnt')

    # constraint Ik
    for joint, controller in zip(joint_Ik[0], joint_Ik[2]):
        lr_parent_constraint(controller, joint)
        lr_scale_constraint(controller, joint)

    # create controller fk
    mainGroup = []
    ctrl = []
    for number, item in enumerate(joint_Fk):
        controller = Lr_Control(match_obj_first_position=item,
                                prefix=item, suffix='ctrl', groups_ctrl=['Main', 'Offset'],
                                ctrl_color='lightPink', ctrl_size=skeleton/4,
                                lock_channels=['v'], shape=CIRCLE, connection=['parentCons', 'scaleCons'])
        ctrl.append(controller.control)
        mainGroup.append(controller.parent_control[0])

        if number > 0:
            mc.parent(mainGroup[number], ctrl[number - 1])

    return mainGroup, joint_Ik[1], joint_Ik[0], joint_Fk

#**********************************************************************************************************************#
#                                        ATTACH TO PATH FUNCTION                                                       #
#**********************************************************************************************************************#
def lr_path_line(curve_attach, curve, prefix, path_size, prefix_rig_name, rig_direction, start_frame, end_frame,
                 locator_group, still_rig_group, still_path_group):
    lr_load_matrix_quad_plugin()

    # query bind and group bind
    anim_grp = 'anim%s_grp' % (prefix_rig_name)
    attach_prefix= 'Attach_loc'
    attr = mc.listAttr(anim_grp, ud=True)
    group_joint = []
    bind_joint = []
    for item in attr:
        grp_jnt = mc.listConnections(anim_grp + '.' + item, d=1)[0]
        group_joint.append(grp_jnt)

    for item in group_joint:
        list_attr = mc.listAttr(item, ud=True)[0]
        bind = mc.listConnections(item + '.' + list_attr, d=1)[0]
        bind_joint.append(bind)

    # world locator
    world_up_loc = mc.spaceLocator(n=prefix+add_prefix+attach_prefix)
    mc.setAttr(world_up_loc[0]+'.translateY', path_size)
    mc.hide(world_up_loc)
    mc.parent(world_up_loc[0], locator_group)

    lr_motion_path(curve_attach=curve_attach, curve=curve, bind_joint=bind_joint, group_joint=group_joint, world_up_loc=world_up_loc,
                   rig_direction=rig_direction, start_frame=start_frame, end_frame=end_frame,
                still_path_group=still_path_group)

def lr_motion_path(curve_attach, curve, bind_joint, group_joint, world_up_loc, rig_direction, start_frame, end_frame,
                   still_path_group):
    arc_length_attach = mc.arclen(curve_attach)
    arc_length =mc.arclen(curve)
    value_length = arc_length_attach / arc_length

    motion_paths =[]
    all_uValue =[]
    range_value = (1.0/len(bind_joint))

    # create motion path node
    for number, (group, joint) in enumerate (zip (group_joint, bind_joint)):
        # motion path
        uValue = range_value * number
        motion_path = pm.pathAnimation(group, fractionMode=True, fa='z', ua='y', wut='objectrotation',
                                       wuo=world_up_loc[0], c=curve_attach,
                                       n=lr_prefix_name(joint) + '_mpt')
        mc.cutKey(motion_path + '.u', time=())
        if rig_direction == 'z':
            mc.setAttr(motion_path+'.inverseFront', 1)
        else:
            mc.setAttr(motion_path+'.inverseFront', 0)

        # add message path animation
        lr_add_message(object_origin=motion_path, object_target=world_up_loc[0], ln=motion_path+'_msg')

        all_uValue.append(uValue)
        motion_paths.append(motion_path)

    # attaching node to object
    all_uValue = sorted(all_uValue, reverse=True)
    value_0_divide = all_uValue[0]/value_length
    value_0_z = (value_0_divide * -1) + 1
    value_0_x = 1- value_0_divide

    for i, ctrls, path_uvalue, in zip(motion_paths, group_joint, all_uValue):
        value_divide = (path_uvalue/value_length)

        key_transform = mc.createNode('transform', n=lr_prefix_name(i) + '_key')
        attr = lr_add_attribute(objects=[key_transform], long_name=['pathUValue'], at="float", keyable=True)
        lr_lock_hide_attr(lock_channel=['t','r','s','v'], ctrl=key_transform)
        lr_add_message(object_origin=key_transform, object_target=still_path_group, ln=key_transform + '_msg')

        if rig_direction == 'z':
            value = (value_divide * -1) + 1
            mc.setKeyframe(key_transform, t=[start_frame], at=attr, v=value)
            mc.setKeyframe(key_transform, t=[end_frame], at=attr, v=value-value_0_z)

            mc.keyTangent(key_transform + '_%s' % attr, edit=True, inTangentType='linear', outTangentType='linear')
            mc.setAttr(key_transform + '_%s' % attr + '.preInfinity', 1)
            mc.setAttr(key_transform + '_%s' % attr + '.postInfinity', 1)

        else:
            mc.setKeyframe(key_transform, t=[start_frame], at=attr, v=value_divide)
            mc.setKeyframe(key_transform, t=[end_frame], at=attr, v=value_divide+value_0_x)

            mc.keyTangent(key_transform + '_%s' % attr, edit=True, inTangentType='linear', outTangentType='linear')

            mc.setAttr(key_transform + '_%s' % attr + '.preInfinity', 1)
            mc.setAttr(key_transform + '_%s' % attr + '.postInfinity', 1)


        mc.setDrivenKeyframe(i + '.u', cd=key_transform + '.%s' % attr, dv=0, v=0)
        mc.setDrivenKeyframe(i + '.u', cd=key_transform + '.%s' % attr, dv=1, v=1)

        mc.keyTangent(i + '_uValue', edit=True, inTangentType='linear', outTangentType='linear')

        mc.setAttr(i + '_uValue' + '.preInfinity', 1)
        mc.setAttr(i + '_uValue' + '.postInfinity', 1)

        mc.parent(key_transform, still_path_group)

    return motion_paths

#**********************************************************************************************************************#
#                                               CREATE RIG FUNCTION                                                    #
#**********************************************************************************************************************#
def lr_create_rig_sorted_joint_tmp():
    tmp_grp = 'tmp_grp'
    list_tmp_jnt = sorted(mc.listConnections(tmp_grp + '.message'))
    # [u'bodyBase_tmp', u'bodyTip_tmp', u'head_tmp', u'jawTip_tmp', u'jaw_tmp', u'leftFang_tmp', u'rightFang_tmp',
    #  u'tongueTip_tmp', u'tongue_tmp', u'upperJawTip_tmp', u'upperJaw_tmp']

    return list_tmp_jnt

def lr_create_rig_tongue(prefix):
    list_tmp_jnt = lr_create_rig_sorted_joint_tmp()
    joint = lr_create_rig_base_tip_jointFk_spline(base=list_tmp_jnt[8], tip=list_tmp_jnt[7], prefix=prefix + 'Tongue', skeleton_number=8)

    mainGroup=[]
    ctrl = []
    for number, item in enumerate (joint):
        controller = Lr_Control(match_obj_first_position=item,
                   prefix=item, suffix='ctrl', groups_ctrl=['Main', 'Offset'],
                   ctrl_color='red', ctrl_size=0.5,
                   lock_channels=['v'], shape=CIRCLE, connection=['parentCons', 'scaleCons'])
        ctrl.append(controller.control)
        mainGroup.append(controller.parent_control[0])

        if number > 0:
            mc.parent(mainGroup[number], ctrl[number - 1])

    return {'joint': joint, 'mainGrp':mainGroup}

def lr_create_rig_right_fang(prefix):
    list_tmp_jnt = lr_create_rig_sorted_joint_tmp()
    setup = lr_create_rig_head_area(position_sorted=list_tmp_jnt[6], joint_name=prefix + 'RightFang_jnt', color='red', shape=CUBE, size=1.0)

    return {
        'ctrl': setup['controller'],
        'offsetGrp': setup['offsetGrp'],
        'mainGrp': setup['mainGrp'],
        'joint': setup['joint'],
    }

def lr_create_rig_left_fang(prefix):
    list_tmp_jnt = lr_create_rig_sorted_joint_tmp()
    setup = lr_create_rig_head_area(position_sorted=list_tmp_jnt[5], joint_name=prefix + 'LeftFang_jnt', color='red', shape=CUBE, size=1.0)
    return {
        'ctrl': setup['controller'],
        'offsetGrp': setup['offsetGrp'],
        'mainGrp': setup['mainGrp'],
        'joint': setup['joint']}

def lr_create_rig_upperJaw(prefix):
    list_tmp_jnt = lr_create_rig_sorted_joint_tmp()
    setup = lr_create_rig_head_area(position_sorted=list_tmp_jnt[10], joint_name=prefix + 'UpperJaw_jnt', color='yellow', shape=SQUAREPLUS, size=3.0)
    return {
        'ctrl': setup['controller'],
        'offsetGrp': setup['offsetGrp'],
        'mainGrp': setup['mainGrp'],
        'joint': setup['joint']}

def lr_create_rig_jaw(prefix):
    list_tmp_jnt = lr_create_rig_sorted_joint_tmp()
    setup = lr_create_rig_head_area(position_sorted=list_tmp_jnt[4], joint_name=prefix + 'Jaw_jnt', color='blue', shape=SQUAREPLUS, size=3.0)
    return {
        'ctrl': setup['controller'],
        'offsetGrp': setup['offsetGrp'],
        'mainGrp': setup['mainGrp'],
        'joint': setup['joint']}

def lr_create_rig_head(prefix):
    list_tmp_jnt = lr_create_rig_sorted_joint_tmp()
    setup = lr_create_rig_head_area(position_sorted=list_tmp_jnt[2], joint_name=prefix + 'Head_jnt', color='red', shape=HEAD, size=3.0)
    return {
        'ctrl': setup['controller'],
        'offsetGrp': setup['offsetGrp'],
        'mainGrp': setup['mainGrp'],
        'joint': setup['joint']}

def lr_create_rig_head_area(position_sorted, joint_name, color, shape, size):
    mc.select(cl=1)
    joint =mc.joint(n=joint_name, rad=0.5)
    mc.delete(mc.parentConstraint(position_sorted, joint))
    controller = Lr_Control(match_obj_first_position=joint,
                            prefix=joint, suffix='ctrl', groups_ctrl=['Main', 'Offset'],
                            ctrl_color=color, ctrl_size=size,
                            lock_channels=['v'], shape=shape, connection=['parentCons','scaleCons'])

    return {'controller':controller.control,
            'offsetGrp' : controller.parent_control[1],
            'mainGrp': controller.parent_control[0],
            'joint':joint}

def lr_create_rig_base_tip_final(prefix, skeleton_number, anim_grp, curve_grp, still_rig_group):
    list_tmp_jnt = lr_create_rig_sorted_joint_tmp()

    bind_joint = lr_create_rig_base_tip_joint_bind(base=list_tmp_jnt[0], tip=list_tmp_jnt[1], prefix=prefix + 'Body',
                                                   skeleton_number=skeleton_number, anim_grp=anim_grp)
    spline_jointFk = lr_base_tip_jointFk_spline(base=list_tmp_jnt[0], tip=list_tmp_jnt[1], prefix=prefix + 'Body',
                                                skeleton_number=skeleton_number)
    # add message
    lr_add_message(object_origin=spline_jointFk['hdl_curve'], object_target=curve_grp,
                   ln=spline_jointFk['hdl_curve'] + '_msg')

    # create reference position
    for joint in bind_joint[0]:
        reference_position = mc.createNode('transform', n=lr_prefix_name(joint) + '_pathRef')
        mc.delete(mc.parentConstraint(joint, reference_position))
        lr_add_message(object_origin=reference_position, object_target=still_rig_group, ln=reference_position + '_msg')
        mc.parent(reference_position, still_rig_group)

    # skinning the joint to the bind curve
    mc.skinCluster(bind_joint[0], spline_jointFk['hdl_curve'],
                   n='%s%s' % (prefix, 'SkinCluster'), tsb=True, bm=0, sm=0, nw=1, mi=1)
    return {'list_jointIk': spline_jointFk['list_jointIk'],
            'spline_hdl' : spline_jointFk['spline_hdl'],
            'hdl_curve':spline_jointFk['hdl_curve'],
            'group_joint': bind_joint[1],
            'ctrl_joint' : bind_joint[2]}

def lr_create_rig_base_tip_joint_bind(base, tip, prefix, skeleton_number, anim_grp, suffix='bind',
                                      shape=STAR, shape_2=CIRCLE, size=2.0, color='red', color_2='yellow'):

    bind_joint = lr_base_tip_split_joint(obj_base=base, obj_tip=tip, prefix=prefix, suffix=suffix,
                                         skeleton_number=skeleton_number / 2)
    group_head = []
    controller_head = []
    for item in bind_joint[0:2]:
        controller = Lr_Control(match_obj_first_position=item,
                                prefix=item, suffix='ctrl', groups_ctrl=['Main', 'Offset'],
                                ctrl_color=color, ctrl_size=size,
                                lock_channels=['v'], shape=shape, connection=['parent'])
        group_head.append(controller.parent_control[0])
        controller_head.append(controller.control)
        lr_add_message(object_origin=item, object_target=controller.parent_control[0], ln=item+'_msg')


    for item in bind_joint[2:]:
        rest_controller = Lr_Control(match_obj_first_position=item,
                   prefix=item, suffix='ctrl', groups_ctrl=['Main', 'Offset'],
                   ctrl_color=color_2, ctrl_size=size,
                   lock_channels=['v'], shape=shape_2, connection=['parent'])
        group_head.append(rest_controller.parent_control[0])
        controller_head.append(rest_controller.control)
        lr_add_message(object_origin=item, object_target=rest_controller.parent_control[0], ln=item+'_msg')


    # add message
    for item in group_head:
        lr_add_message(object_origin=item, object_target=anim_grp, ln=item+'_msg')

    return bind_joint, group_head, controller_head

def lr_create_rig_base_tip_jointFk_spline(base, tip, prefix, skeleton_number, suffix='jnt'):
    list_jointIk = lr_base_tip_split_joint(obj_base=base, obj_tip=tip, prefix=prefix, suffix=suffix,
                                           skeleton_number=skeleton_number)
    for i in range(len(list_jointIk)):
        if i > 0:
            mc.parent(list_jointIk[i], list_jointIk[i - 1])

    return list_jointIk

#**********************************************************************************************************************#
#                                                   GENERAL FUNCTION                                                   #
#**********************************************************************************************************************#
def lr_add_message(object_origin, object_target, ln=''):
    if mc.objExists(object_target+'.%s' % ln):
        mc.connectAttr(object_origin + '.message', '%s.%s' % (object_target, ln))
    else:
        mc.addAttr(object_target, ln=ln, at='message')
        mc.connectAttr(object_origin + '.message', '%s.%s' % (object_target, ln))

def lr_skin_matrix_list_from_joint(obj):
    for item in lr_joint_destination_matrix(obj):
        split = item.split('.')[1:]
        integer = int((split[0].split('[')[-1][:-1]))
        return integer

def lr_joint_destination_matrix(obj):
    list_connection = pm.listConnections(obj + '.worldMatrix[0]', p=True)
    return list_connection

def lr_query_skin_name(obj):
    # get the skincluster name
    relatives = pm.listRelatives(obj, type="shape")
    skin_cluster = pm.listConnections(relatives, type="skinCluster")
    if not skin_cluster:
        return pm.error("Please add bind skin to '%s' before create or reconnect or disconnect tweak controller!" % obj[0])
    else:
        return skin_cluster[0]

def lr_connect_follicle_rotation(follicleNode, follicleTransf):
    conn = mc.connectAttr(follicleNode + '.outRotate', follicleTransf + '.rotate')
    return conn

def lr_connect_follicle_translation(follicleNode, follicleTransf):
    conn = mc.connectAttr(follicleNode + '.outTranslate', follicleTransf + '.translate')
    return conn

def lr_dic_connect_follicle(connect, follicleNode, follicleTransf):
    dic = {'rotateConn': lr_connect_follicle_rotation,
           'transConn': lr_connect_follicle_translation,
           }
    for con in connect:
        if con in dic.keys():
            dic[con](follicleNode, follicleTransf)
        else:
            return mc.warning("Your %s key name is wrong. Please check on the key list connection!" % con)
    return dic

def lr_item_follicle(items, obj_tansform, suffix):
    follicles = []
    follicle_shape = []
    for i in items:
        follicle = lr_create_follicle_selection(i, obj_tansform, connect_follicle=['rotateConn', 'transConn'])[0]
        rename_fol = mc.rename(follicle, '%s_%s' % (lr_prefix_name(i), suffix))
        follicles.append(rename_fol)
        list_relatives_follicleShape = mc.listRelatives(rename_fol, s=1)[0]
        follicle_shape.append(list_relatives_follicleShape)

    return {'item': items,
            'follicle': follicles,
            'folShape': follicle_shape}

def lr_create_follicle_selection(obj_select, obj_mesh, connect=None, prefix=None, suffix=None, scale=None, connect_follicle=['']):
    obj_mesh = mc.listRelatives(obj_mesh, s=1)[0]

    closest_node = None
    # If the inputSurface is of type 'nurbsSurface', connect the surface to the closest node
    if mc.objectType(obj_mesh) == 'nurbsSurface':
        closest_node = mc.createNode('closestPointOnSurface')
        mc.connectAttr((obj_mesh + '.local'), (closest_node + '.inputSurface'))

    # If the inputSurface is of type 'mesh', connect the surface to the closest node
    elif mc.objectType(obj_mesh) == 'mesh':
        closest_node = mc.createNode('closestPointOnMesh')
        mc.connectAttr((obj_mesh + '.outMesh'), (closest_node + '.inMesh'))
    else:
        mc.error('please check your type object. Object must be either nurbs or mesh')

    # query object selection
    xform = mc.xform(obj_select, ws=True, t=True, q=True)

    # set the position of node according to the loc
    mc.setAttr(closest_node + '.inPositionX', xform[0])
    mc.setAttr(closest_node + '.inPositionY', xform[1])
    mc.setAttr(closest_node + '.inPositionZ', xform[2])

    # create follicle
    follicle_node = mc.createNode('follicle')

    # query the transform follicle
    follicle_transform = mc.listRelatives(follicle_node, type='transform', p=True)

    # connecting the shape follicle to transform follicle
    lr_dic_connect_follicle(connect_follicle, follicle_node, follicle_transform[0])

    # connect the world matrix mesh to the follicle shape
    mc.connectAttr(obj_mesh + '.worldMatrix[0]', follicle_node + '.inputWorldMatrix')

    # connect the output mesh of mesh to input mesh follicle
    if mc.objectType(obj_mesh) == 'nurbsSurface':
        mc.connectAttr((obj_mesh + '.local'), (follicle_node + '.inputSurface'))

    # If the inputSurface is of type 'mesh', connect the surface to the follicle
    if mc.objectType(obj_mesh) == 'mesh':
        mc.connectAttr(obj_mesh + '.outMesh', follicle_node + '.inputMesh')

    # turn off the simulation follicle
    mc.setAttr(follicle_node + '.simulationMethod', 0)

    # get u and v output closest point on mesh node
    par_u = mc.getAttr(closest_node + '.result.parameterU')
    par_v = mc.getAttr(closest_node + '.result.parameterV')

    # connect output closest point on mesh node to follicle
    mc.setAttr(follicle_node + '.parameterU', par_u)
    mc.setAttr(follicle_node + '.parameterV', par_v)

    # deleting node
    mc.delete(closest_node)

    # rename follicle
    if prefix or suffix:
        follicle_transform = mc.rename(follicle_transform, '%s_%s' % (lr_prefix_name(prefix), suffix))
    else:
        follicle_transform = mc.rename(follicle_transform, '%s_%s' % (lr_prefix_name(obj_select), 'fol'))

    if scale:
        lr_scale_constraint(scale, follicle_transform, mo=1)

    # listing the shape of follicle
    follicle_shape = mc.listRelatives(follicle_transform, s=1)[0]

    if connect:
        lr_connections(connect, follicle_transform, obj_select)
    else:
        return follicle_transform, follicle_shape

    return follicle_transform, follicle_shape

def lr_base_tip_jointFk_spline(base, tip, prefix, skeleton_number, spline_handle=True):
    list_jointIk = lr_create_rig_base_tip_jointFk_spline(base=base, tip=tip, prefix=prefix, skeleton_number=skeleton_number)

    head_ik_joint = mc.xform(list_jointIk[0], q=1, ws=True, t=1)
    tail_ik_joint = mc.xform(list_jointIk[-1], q=1, ws=True, t=1)

    # create curve for ik spline
    curve_ik_spline_detail = mc.curve(d=3, ep=[head_ik_joint, tail_ik_joint])
    mc.rebuildCurve(curve_ik_spline_detail, ch=0, rpo=1, rt=0, end=1, kr=0, kcp=0,
                    kep=1, kt=0, s=(skeleton_number / 2) - 1, d=3, tol=0.01)

    hdl_curve = mc.rename(curve_ik_spline_detail, '%s_crv' % (prefix + 'Fk'))

    # # reverse direction
    # if reverse:
    #     mc.reverseCurve(hdl_curve, ch=True, rpo=True)

    if spline_handle:
        spline_hdl = mc.ikHandle(sj=list_jointIk[0], ee=list_jointIk[-1],
                                sol='ikSplineSolver',
                                n='%s_hdl' % (prefix + 'Fk'), ccv=False,
                                c=hdl_curve, ns=1, rootOnCurve=True)

        return {'list_jointIk': list_jointIk, 'spline_hdl':spline_hdl[0],
                'hdl_curve': hdl_curve}
    else:
        return {'list_jointIk': list_jointIk,
                'hdl_curve': hdl_curve}

def lr_base_tip_split_joint(obj_base, obj_tip, prefix, suffix, skeleton_number=1):
    base_xform = mc.xform(obj_base, q=1, ws=1, t=1)
    tip_xform = mc.xform(obj_tip, q=1, ws=1, t=1)

    base_vector = om.MVector(base_xform[0], base_xform[1], base_xform[2])
    tip_vector = om.MVector(tip_xform[0], tip_xform[1], tip_xform[2])

    split_vector = (tip_vector - base_vector)
    segment_vector = (split_vector / (skeleton_number - 1))

    segment_location = (base_vector + segment_vector)

    mc.select(cl=1)
    skeleton_base = mc.joint(name='%s%s_%s' % (prefix, str(1).zfill(2), suffix))
    mc.delete(mc.parentConstraint(obj_base, skeleton_base))
    mc.makeIdentity(skeleton_base, apply=True, t=1, r=1, s=1, n=0, pn=1)

    list = []
    new_list = []
    for i in range(0, (skeleton_number - 2)):
        mc.select(cl=1)
        segment = mc.joint()
        mc.delete(mc.parentConstraint(obj_base, segment))
        mc.makeIdentity(segment, apply=True, t=1, r=1, s=1, n=0, pn=1)

        new_name = mc.rename(segment, str('%s%01d_%s' % (prefix, (i + 2), 'ref')))
        list.append(new_name)
        mc.move(segment_location.x, segment_location.y, segment_location.z, new_name)
        segment_location = segment_location + segment_vector

    mc.select(cl=1)
    skeleton_tip = mc.joint(name='%s%s_%s' % (prefix, str(list.index(list[-1]) + 3).zfill(2), suffix))
    mc.delete(mc.parentConstraint(obj_tip, skeleton_tip))
    mc.makeIdentity(skeleton_tip, apply=True, t=1, r=1, s=1, n=0, pn=1)

    for i in list:
        new_name = mc.rename(i, '%s%s_%s' % (prefix, str(list.index(i) + 2).zfill(2), suffix))
        new_list.append(new_name)
    new_list.append(skeleton_base)
    new_list.append(skeleton_tip)

    # create controller
    return sorted(new_list)

def lr_scale_curve(size_obj, shape):
    scaleShp = [[size_obj * i for i in j] for j in shape]
    return scaleShp

def lr_controller_shape(shape):
    createCrv = mc.curve(d=1, p=shape)
    return createCrv

def lr_group_parents(groups, prefix, suffix, number='',):
    # create group hierarchy
    grps = []
    for i in range(len(groups)):
        grps.append(
            mc.createNode('transform', n="%s%s%s%s_%s" % (prefix, suffix, groups[i], number, 'grp')))

        if i > 0:
            mc.parent(grps[i],grps[i - 1])

    return grps

def lr_set_color(ctrl, color):
    color_dic = {'blue': 6, 'darkGreen': 7, 'darkPurple': 8, 'dullRed': 12, 'red': 13, 'navy': 15,
                 'yellow': 17, 'turquoiseBlue': 18, 'turquoiseGreen': 19, 'lightPink': 20, 'lightYellow': 22,
                 'dullGreen': 23, 'dullYellow': 25, 'greenYellow': 26, 'greenBlue': 27, 'blueGreen': 28,
                 'lightNavy': 29, 'violet': 30, 'ruby': 31
    }
    if color in color_dic.keys():
        list_relatives = mc.listRelatives(ctrl, s=1)[0]
        mc.setAttr(list_relatives + '.ove', 1)
        mc.setAttr(list_relatives + '.ovc', color_dic[color])
        return list_relatives
    else:
        return mc.warning("Could not find %s name color. Please check color name!" % color)

def lr_lock_hide_attr(lock_channel, ctrl):
    attr_lock_list = []
    for lc in lock_channel:
        if lc in ['t', 'r', 's']:
            for axis in ['x', 'y', 'z']:
                at = lc + axis
                attr_lock_list.append(at)
        else:
            attr_lock_list.append(lc)
    for at in attr_lock_list:
        mc.setAttr(ctrl + '.' + at, l=1, k=0)
    return attr_lock_list

def lr_group_object(grp_name_list, obj_base, prefix, suffix, match_pos=None, side=''):
    list_relatives = mc.listRelatives(obj_base, ap=1)

    cGrp = lr_group_parents(grp_name_list, '%s' % prefix, suffix.title(), side)

    if match_pos:
        lr_match_position(match_pos, cGrp[0])
        #match_scale(match_pos, cGrp[0])

    if list_relatives == None:
        mc.parent(obj_base, cGrp[-1])
    else:
        # parent group offset to list relatives
        mc.parent(cGrp[0], list_relatives)
        # parent obj to grp offset
        mc.parent(obj_base, cGrp[-1], )

    return cGrp

def lr_match_position(obj_base, obj_target):
    mc.delete(lr_parent_constraint(obj_base, obj_target, mo=0))

def lr_parent_constraint(obj_base, obj_target, mo=1):
    par_constraint = mc.parentConstraint(obj_base, obj_target, mo=mo)[0]
    split = par_constraint.split('_')
    x = '_'.join(split[:-1])
    n = x.replace(x, x + '_pac')
    new_name = [mc.rename(par_constraint, n)]
    return new_name

def lr_orient_constraint(obj_base, obj_target, mo=1):
    orient_constraint = mc.orientConstraint(obj_base, obj_target, mo=mo)[0]
    split = orient_constraint.split('_')
    x = '_'.join(split[:-1])
    n = x.replace(x, x + '_oc')
    new_name = [mc.rename(orient_constraint, n)]
    return new_name

def lr_point_constraint(obj_base, obj_target, mo=1):
    point_constraint = mc.pointConstraint(obj_base, obj_target, mo=mo)[0]
    split = point_constraint.split('_')
    x = '_'.join(split[:-1])
    n = x.replace(x, x + '_pc')
    new_name = [mc.rename(point_constraint, n)]
    return new_name

def lr_scale_constraint(obj_base, obj_target, mo=1):
    scale_constraint = mc.scaleConstraint(obj_base, obj_target, mo=mo)[0]
    split = scale_constraint.split('_')
    x = '_'.join(split[:-1])
    n = x.replace(x, x + '_sc')
    new_name = [mc.rename(scale_constraint, n)]

    return new_name

def lr_parent_object(objBase, objTgt):
    parent_object = mc.parent(objTgt, objBase)
    return parent_object

def lr_connect_attr_object(objBase, objTgt):
    lr_connect_attr_translate(objBase, objTgt)
    lr_connect_attr_rotate(objBase, objTgt)
    lr_connect_attr_scale(objBase, objTgt)
    return

def lr_connect_attr_scale(obj_base, obj_target):
    list_relatives = mc.listRelatives(obj_target, ap=1)
    if list_relatives == True:
        attr = mc.connectAttr(obj_base + '.scaleX', list_relatives + '.scaleX')
        attr = mc.connectAttr(obj_base + '.scaleY', list_relatives + '.scaleY')
        attr = mc.connectAttr(obj_base + '.scaleZ', list_relatives + '.scaleZ')

    else:
        attr = mc.connectAttr(obj_base + '.scaleX', obj_target + '.scaleX')
        attr = mc.connectAttr(obj_base + '.scaleY', obj_target + '.scaleY')
        attr = mc.connectAttr(obj_base + '.scaleZ', obj_target + '.scaleZ')
    return attr

def lr_connect_attr_translate(objBase, objTgt):
    list_relatives = mc.listRelatives(objTgt, ap=1)
    if list_relatives == True:
        translate_attr = mc.connectAttr(objBase + '.translate', list_relatives + '.translate')
    else:
        translate_attr = mc.connectAttr(objBase + '.translate', objTgt + '.translate')
    return translate_attr

def lr_connect_attr_rotate(obj_base, obj_target):
    list_relatives = mc.listRelatives(obj_target, ap=1)
    if list_relatives == True:
        rotate_attr = mc.connectAttr(obj_base + '.rotate', list_relatives + '.rotate')
    else:
        rotate_attr = mc.connectAttr(obj_base + '.rotate', obj_target + '.rotate')
    return rotate_attr

def lr_connections(connect, ctrl, obj):
    dic = {'parentCons': lr_parent_constraint, 'pointCons':  lr_point_constraint, 'orientCons':  lr_orient_constraint,
           'scaleCons':  lr_scale_constraint, 'parent':  lr_parent_object, 'connectAttr':  lr_connect_attr_object,
           'connectTrans':  lr_connect_attr_translate, 'connectOrient':  lr_connect_attr_rotate,
           'connectScale':  lr_connect_attr_scale,
           }
    rs = {}
    for con in connect:
        if con in dic.keys():
            rs[con] = dic[con](ctrl, obj)
        else:
            return mc.error("Your %s key name is wrong. Please check on the key list connection!" % con)
    return rs

def lr_prefix_name(obj):
    if '_' in obj:
        get_prefix_name = obj.split('_')[:-1]
        joining = '_'.join(get_prefix_name)
        return joining
    else:
        return obj

def lr_load_matrix_quad_plugin():
    # load Plug-ins
    matrix_node = mc.pluginInfo('matrixNodes.mll', query=True, loaded=True)
    quat_node = mc.pluginInfo('quatNodes.mll', query=True, loaded=True)

    if not matrix_node:
        mc.loadPlugin('matrixNodes.mll')

    if not quat_node:
        mc.loadPlugin('quatNodes.mll')

def lr_add_attribute(objects=[], long_name=[''], nice_name='', separator=False, keyable=False, channel_box=False, **kwargs):
    # For each object
    for obj in objects:
        # For each attribute
        for x in range(0, len(long_name)):
            # See if a niceName was defined
            attr_nice = '' if not nice_name else nice_name[x]
            # If the attribute does not exists
            if not mc.attributeQuery(long_name[x], node=obj, exists=True):
                # Add the attribute
                mc.addAttr(obj, longName=long_name[x], niceName=attr_nice, **kwargs)
                # If lock was set to True
                mc.setAttr((obj + '.' + long_name[x]), k=keyable, e=1, cb=channel_box) if separator else mc.setAttr(
                    (obj + '.' + long_name[x]), k=keyable, e=1, cb=channel_box)
    return long_name[0]


# class Lr_MotionPaths():
#     def __init__(self, curve='', world_up_loc='', set_value_length =1, controller=False):
#         # load Plug-ins
#         lr_load_matrix_quad_plugin()
#
#         all_grp = mc.group(empty=True, n=lr_prefix_name(curve) + 'MotionLoop' + '_grp')
#         setup_grp = mc.group(empty=True, n=lr_prefix_name(curve) + 'Setup' + '_grp')
#         grp_jnt = mc.group(empty=True, n=lr_prefix_name(curve) + 'Joints' + '_grp')
#         grp_crv = mc.group(empty=True, n=lr_prefix_name(curve) + 'Crv' + '_grp')
#
#         create_ik = lr_joint_on_curve(curve=curve, world_up_loc=world_up_loc, delete_group=False,
#                                       ctrl=controller)
#         arc_length = mc.arclen(curve)
#
#         value_length = arc_length/set_value_length
#
#
#         ctrl = Lr_Control(match_obj_first_position=create_ik['joints'][0], prefix=lr_prefix_name(curve),
#                           shape=STAR,
#                           groups_ctrl=['Zro'], ctrl_size=10.0,
#                           ctrl_color='blue', lock_channels=['r', 's', 'v'])
#
#         attribute_speed = lr_add_attribute(objects=[ctrl.control], long_name=['speed'], min=0, dv=0, max=50, at="float",
#                                            keyable=True)
#
#         lr_change_position(ctrl.control, 'xy')
#
#         for i, ctrls in zip(create_ik['motionPath'], create_ik['ctrl']):
#
#             motion_path_uvalue = mc.getAttr(i + '.u')
#
#             mult_timing = mc.shadingNode('multDoubleLinear', asUtility=1, n=lr_prefix_name(i) + 'TimeMult' + '_mdl')
#             mc.connectAttr(ctrl.control + '.%s' % attribute_speed, mult_timing + '.input1')
#             mc.connectAttr('time1.outTime', mult_timing + '.input2')
#
#             add_speed = mc.shadingNode('addDoubleLinear', asUtility=1, n=lr_prefix_name(i) + 'SpeedAdd' + '_adl')
#             mc.setAttr(add_speed + '.input2', (((motion_path_uvalue/value_length) * 1000)))
#
#             mult_offset = mc.shadingNode('multiplyDivide', asUtility=1, n=lr_prefix_name(i) + 'SpeedOffset' + '_mdn')
#             mc.setAttr(mult_offset + '.operation', 2)
#             mc.setAttr(mult_offset + '.input2X', 1000)
#             mc.connectAttr(add_speed + '.output', mult_offset + '.input1X')
#
#             condition_speed = mc.shadingNode('condition', asUtility=1, n=lr_prefix_name(i) + 'Speed' + '_cnd')
#             mc.setAttr(condition_speed + '.operation', 2)
#             mc.connectAttr(mult_timing + '.output', condition_speed + '.firstTerm')
#
#             add_value = mc.shadingNode('plusMinusAverage', asUtility=1, n=lr_prefix_name(i) + 'Speed' + '_pma')
#             mc.connectAttr(mult_offset + '.outputX', add_value + '.input1D[0]')
#             mc.setAttr(add_value + '.input1D[1]', 1)
#
#             mc.connectAttr(mult_offset + '.outputX', condition_speed + '.colorIfTrueR')
#             mc.connectAttr(add_value + '.output1D', condition_speed + '.colorIfFalseR')
#
#             mc.setDrivenKeyframe(i + '.u', cd=condition_speed + '.outColorR', dv=0, v=0)
#             mc.setDrivenKeyframe(i + '.u', cd=condition_speed + '.outColorR', dv=1, v=1)
#
#             mc.keyTangent(i + '_uValue', edit=True, inTangentType='linear', outTangentType='linear')
#
#             mc.setAttr(i + '_uValue' + '.preInfinity', 3)
#             mc.setAttr(i + '_uValue' + '.postInfinity', 3)
#
#             if controller:
#                 pos_offset_attr = lr_add_attribute(objects=[ctrls], long_name=['posOffset'], dv=0, min=0, at="float",
#                                                    keyable=True)
#
#                 obj_offset = mc.shadingNode('plusMinusAverage', asUtility=1, n=lr_prefix_name(i) + 'ObjSpeed' + '_pma')
#                 mc.connectAttr(mult_timing + '.output', obj_offset + '.input1D[0]')
#                 mc.connectAttr(obj_offset + '.output1D', add_speed + '.input1')
#
#                 obj_condition = mc.shadingNode('condition', asUtility=1, n=lr_prefix_name(i) + 'ObjSpeed' + '_cnd')
#                 mc.setAttr(obj_condition + '.operation', 4)
#                 mc.connectAttr(mult_timing + '.output', obj_condition + '.firstTerm')
#
#                 mc.setDrivenKeyframe(obj_condition + '.colorIfTrueR', cd=ctrls + '.%s' % pos_offset_attr, dv=0, v=0)
#                 mc.setDrivenKeyframe(obj_condition + '.colorIfTrueR', cd=ctrls + '.%s' % pos_offset_attr, dv=1, v=-1)
#
#                 mc.keyTangent(obj_condition + '_colorIfTrueR', edit=True, inTangentType='spline', outTangentType='spline')
#
#                 mc.setAttr(obj_condition + '_colorIfTrueR' + '.preInfinity', 1)
#                 mc.setAttr(obj_condition + '_colorIfTrueR' + '.postInfinity', 1)
#
#                 mc.setDrivenKeyframe(obj_condition + '.colorIfFalseR', cd=ctrls + '.%s' % pos_offset_attr, dv=0, v=0)
#                 mc.setDrivenKeyframe(obj_condition + '.colorIfFalseR', cd=ctrls + '.%s' % pos_offset_attr, dv=1, v=1)
#
#                 mc.keyTangent(obj_condition + '_colorIfFalseR', edit=True, inTangentType='spline', outTangentType='spline')
#
#                 mc.setAttr(obj_condition + '_colorIfFalseR' + '.preInfinity', 1)
#                 mc.setAttr(obj_condition + '_colorIfFalseR' + '.postInfinity', 1)
#
#                 mc.connectAttr(obj_condition + '.outColorR', obj_offset + '.input1D[1]')
#
#             else:
#                 mc.connectAttr(mult_timing + '.output', add_speed + '.input1')
#
#             mc.setAttr(i + '.u', lock=True)
#
#         decompose = mc.shadingNode('decomposeMatrix', asUtility=1, n=lr_prefix_name(curve) + 'Scale' + 'dmt')
#         mc.connectAttr(grp_crv + '.worldMatrix[0]', decompose + '.inputMatrix')
#
#         for i in create_ik['joints']:
#             mc.connectAttr(decompose + '.outputScale', i + '.scale')
#             lr_lock_attr(['t', 'r', 's'], i)
#
#         mc.parent(create_ik['joints'], grp_jnt)
#         # mc.parent(createIk['wUpLocGrp'], grpJnt)
#
#         mc.parent(curve, grp_crv)
#
#         mc.parent(grp_jnt, grp_crv, setup_grp)
#         mc.parent(ctrl.parent_control[0], setup_grp, all_grp)
#
#         # mc.setAttr(createIk['wUpLoc']+'.visibility', 0)
#         lr_lock_attr(['t', 'r', 's'], curve)
#         lr_lock_attr(['t', 'r', 's'], grp_jnt)
#         lr_lock_attr(['t', 'r', 's'], setup_grp)
#
#         mc.select(cl=1)

# def lr_joint_on_curve(curve='', world_up_loc='', spline_ik=None, delete_group=True, ctrl=False):
#     newJnt = lr_create_joint_lid(curve)
#
#     num = (1.0 / (int(newJnt[3]) - 1))
#
#     transform = []
#     controls = []
#     motion_paths = []
#     joints = []
#     ikHdl = None
#
#     for n, i in enumerate(newJnt[0]):
#         ranges = num * n
#
#         if ctrl:
#             new_transform = Lr_Control(match_obj_first_position=i, prefix=lr_prefix_name(i) + 'Jnt', shape=CIRCLE,
#                                        groups_ctrl=['Zro'], ctrl_size=2.0,
#                                        ctrl_color='blue', lock_channels=['r', 's', 'v'],
#                                        connection=['parent'])
#             motion_path = mc.pathAnimation(new_transform.parent_control[0], fractionMode=True, fa='z', ua='x',
#                                            wut='objectrotation',
#                                            wuo=world_up_loc,
#                                            c=curve,
#                                            n=lr_prefix_name(i) + '_mpt')
#
#             transform.append(new_transform.parent_control[0])
#             controls.append(new_transform.control)
#             new_transform = new_transform.control
#
#         else:
#             new_transform = mc.createNode('transform', n=lr_prefix_name(i) + 'Jnt_grp')
#             mc.parent(i, new_transform)
#             motion_path = mc.pathAnimation(new_transform, fractionMode=True, fa='z', ua='x',
#                                            wut='objectrotation',
#                                            wuo=world_up_loc,
#                                            c=curve,
#                                            n=lr_prefix_name(i) + '_mpt')
#             transform.append(new_transform)
#             controls.append(newJnt[0])
#
#         mc.cutKey(motion_path + '.u', time=())
#         mc.setAttr(motion_path + '.u', ranges)
#         motion_paths.append(motion_path)
#
#         mc.setAttr(i + '.translate', 0, 0, 0, type='double3')
#         mc.setAttr(i + '.rotate', 0, 0, 0, type='double3')
#
#         joints.append(i)
#
#         if delete_group:
#             mc.parent(joints[n], w=True)
#             mc.delete(new_transform + '.tx', icn=1)
#             mc.delete(new_transform + '.ty', icn=1)
#             mc.delete(new_transform + '.tz', icn=1)
#             mc.delete(new_transform + '.rx', icn=1)
#             mc.delete(new_transform + '.ry', icn=1)
#             mc.delete(new_transform + '.rz', icn=1)
#             mc.xform(new_transform, ws=True, ro=(0, 0, 0))
#             mc.delete(motion_path)
#             mc.delete(new_transform)
#
#             if n > 0:
#                 mc.parent(joints[n], joints[n - 1])
#
#             mc.joint(joints[0], e=True, oj='xyz', sao='yup', ch=True, zso=True)
#
#     if spline_ik:
#         if not delete_group:
#             mc.error('Spline Ik cannot be created. Please delGrp set to True in order to remove group parent joints!')
#         else:
#             ikHdl = mc.ikHandle(sj=joints[0], ee=joints[-1], c=curve, sol='ikSplineSolver', ccv=False,
#                                 n=lr_prefix_name(curve) + '_ikh')
#
#         return {'joints': transform,
#                 'motionPath': motion_paths,
#                 'ctrl': controls,
#                 'ikHdl': ikHdl,
#                 'curve': curve}
#
#
#     return {'joints': transform,
#             'motionPath': motion_paths,
#             'ctrl': controls,
#             'ikHdl': ikHdl,
#             'wUpLoc': newJnt[1],
#             'curve': curve}

# def lr_create_joint_lid(crv):
#     all_joint = []
#     all_locator = []
#     ranges = []
#     for i, v in enumerate(mc.ls('%s.cv[0:*]' % crv, fl=True)):
#         # create joint
#         mc.select(cl=1)
#         joint = mc.joint(n='%s%02d%s' % (lr_prefix_name(crv), (i + 1), '_jnt'), rad=0.1)
#         pos = mc.xform(v, q=1, ws=1, t=1)
#         mc.xform(joint, ws=1, t=pos)
#         all_joint.append(joint)
#
#         ranges.append(i)
#
#     length = len(ranges)
#     return all_joint, all_locator, ranges, length

# def lr_change_position(shape, destination):
#     points = mc.ls('%s.cv[0:*]' % shape, fl=True)
#
#     for i in points:
#         xforms = mc.xform(i, q=1, os=1, t=1)
#         forms_x = xforms[0]
#         forms_y = xforms[1]
#         forms_z = xforms[2]
#         rev_forms_x = xforms[0] * -1
#         rev_forms_y = xforms[1] * -1
#         rev_forms_z = xforms[2] * -1
#
#         if destination == '-':
#             move = mc.setAttr(i + '.xValue', rev_forms_x)
#             move = mc.setAttr(i + '.yValue', rev_forms_y)
#             move = mc.setAttr(i + '.zValue', rev_forms_z)
#
#         elif destination == 'xy' or destination == 'yx':
#             move = mc.setAttr(i + '.xValue', forms_y)
#             move = mc.setAttr(i + '.yValue', forms_x)
#             move = mc.setAttr(i + '.zValue', forms_z)
#
#         elif destination == 'xz' or destination == 'zx':
#             move = mc.setAttr(i + '.xValue', forms_z)
#             move = mc.setAttr(i + '.yValue', forms_y)
#             move = mc.setAttr(i + '.zValue', forms_x)
#
#         elif destination == 'yz' or destination == 'zy':
#             move = mc.setAttr(i + '.xValue', forms_x)
#             move = mc.setAttr(i + '.yValue', forms_z)
#             move = mc.setAttr(i + '.zValue', forms_y)
#
#         else:
#             mc.error('please check your dest parameter name!')

# def lr_lock_attr(lock_channel, ctrl):
#     attrLockList = []
#     for lc in lock_channel:
#         if lc in ['t', 'r', 's']:
#             for axis in ['x', 'y', 'z']:
#                 at = lc + axis
#                 attrLockList.append(at)
#         else:
#             attrLockList.append(lc)
#
#     for at in attrLockList:
#         mc.setAttr(ctrl + '.' + at, l=1)
#
#     return attrLockList

#**********************************************************************************************************************#
#                                                   SKIN CTRL FUNCTION                                                 #
#**********************************************************************************************************************#
def lr_readSelectedWeight(weightFolderPath=''):
    # Import skin weight values into selected geometries
    # sels = mc.ls(sl=True)
    sels = [u'SNAKE_Viper_Body_A_Mesh', u'SNAKE_Viper_Head_A_Mesh', u'SNAKE_Viper_Eye_A_Mesh']
    for sel in sels:

        if not weightFolderPath:
            dataFld = lr_getDataFld()
        else:
            dataFld = os.path.normpath(weightFolderPath)
        fn = '%sWeight.txt' % sel

        try:
            print('Importing %s.' % sel)
            lr_readWeight(sel, os.path.join(dataFld, fn))
            print('Importing %s done.' % fn)
        except Exception as e:
            print('Cannot find weight file for %s' % sel)
            print(e)

    mc.select(sels)
    mc.confirmDialog(title='Progress', message='Importing weight is done.')

def lr_getDataFld():
    # wfn = mc.file( q = True , sn = True )
    wfn = pm.sceneName()
    tmpAry = wfn.split('/')
    tmpAry[-2] = 'data'

    dataFld = '/'.join(tmpAry[0:-1])

    if not os.path.isdir(dataFld):
        os.mkdir(dataFld)

    return dataFld

def lr_readWeight(geo='', fn=''):
    print('Loading %s' % fn)
    fid = open(fn, 'r')
    wDct = pickle.load(fid)
    fid.close()

    infs = wDct['influences']

    for inf in infs:
        if not mc.objExists(inf):
            print('Scene has no %s ' % inf)

    oSkn = mm.eval('findRelatedSkinCluster "%s"' % geo)
    if oSkn:
        mc.skinCluster(oSkn, e=True, ub=True)

    tmpSkn = mc.skinCluster(infs[0], geo, tsb=True)[0]

    for inf in infs[1:]:
        infTyp = mc.objectType(inf)
        if infTyp == 'joint':
            mc.skinCluster(tmpSkn, e=True, ai=inf, lw=True)
        elif infTyp == 'transform':
            baseInf = mc.duplicate(inf)[0]
            mc.setAttr('%s.v' % baseInf, 0)
            baseInf = mc.rename(baseInf, '%sBase' % baseInf)
            shp = mc.listRelatives(baseInf, s=True, f=True, ni=True)[0]
            mc.skinCluster(tmpSkn, e=True, lw=True, ug=True, dr=4, ps=0, ns=10, wt=0,
                           ai=inf, bsh=shp)

    skn = mc.rename(tmpSkn, wDct['name'])
    mc.setAttr('%s.skinningMethod' % skn, wDct['skinningMethod'])
    mc.setAttr('%s.useComponents' % skn, wDct['useComponents'])

    sknSet = mc.listConnections('%s.message' % skn, d=True, s=False)[0]
    mc.rename(sknSet, wDct['set'])

    for inf in infs:
        mc.setAttr('%s.liw' % inf, False)

    mc.setAttr('%s.normalizeWeights' % skn, False)
    mc.skinPercent(skn, geo, nrm=False, prw=100)
    mc.setAttr('%s.normalizeWeights' % skn, True)

    vtxNo = mc.polyEvaluate(geo, v=True)

    for ix in xrange(vtxNo):
        for iy in xrange(len(infs)):
            wVal = wDct[ix][iy]
            if wVal:
                wlAttr = '%s.weightList[%s].weights[%s]' % (skn, ix, iy)
                mc.setAttr(wlAttr, wVal)

        # Percent calculation
        if ix == (vtxNo - 1):
            print('100%% done.')
        else:
            prePrcnt = 0
            if ix > 0:
                prePrcnt = int((float(ix - 1) / vtxNo) * 100.00)

            prcnt = int((float(ix) / vtxNo) * 100.00)

            if not prcnt == prePrcnt:
                print('%s%% done.' % str(prcnt))

def lr_readAllCtrl(search='', replace=''):
    dataFld = lr_getDataFld()

    if not os.path.isdir(dataFld):
        os.mkdir(dataFld)

    ctrls = mc.ls("*trl")
    fn = '%s/ctrlShape.txt' % dataFld
    print(fn)
    lr_readCtrlShape(ctrls, fn, search=search, replace=replace)

    print('Importing all control shape is done.')

def lr_readCtrlShape(ctrls=[], fn='', search='', replace=''):
    print(fn)
    fid = open(fn, 'r')
    ctrlDct = pickle.load(fid)
    fid.close()

    for key in ctrlDct.keys():
        # print key
        if search:
            currVtx = key.replace(search, replace)
        else:
            currVtx = key

        if '.' in currVtx:
            if mc.objExists(currVtx):
                mc.xform(currVtx, os=True, t=ctrlDct[currVtx])
        else:
            if mc.objExists(currVtx):
                mc.setAttr('%s.overrideEnabled' % currVtx, 1)
                mc.setAttr('%s.overrideColor' % currVtx, ctrlDct[currVtx])